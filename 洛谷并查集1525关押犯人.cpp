#include <cstdio>
#include <algorithm>
using namespace std;
struct data { 
	int x, y, z;
};

data f[100005];
int n, m, b[20005], i;

inline bool cmp(data a, data b)//重写cmp函数
{
	return a.z > b.z;
}

int pre[20005], nodeNum[20005]; // pre[a] == b表示a的父亲是b, nodeNum[i] == j表示根节点为i的树上有j个节点

void Init(int n) {
	// 最大的时候终止的时候 自己是自己的父亲
	for (int i = 1; i <= n; i++) {
		pre[i] = i;
		nodeNum[i] = 1;
	}
}

// 这是非递归的找父亲
int Find(int x) // Find(a)的返回值即是a的祖先 最大的那个
{
	int t = x;

	// 通过不断的找父亲操作，最终找到x的祖先，跳出就是自己是自己的祖先
	while (x != pre[x])
		x = pre[x];
	// 这里已经找到最老的祖先就是 x 了

	// 优化 避免树太长     这就是有在压缩优化了
	// 把这一路上的pre都直接指向最老祖先
	if (t != x) {
		int tFa = pre[t];  // 暂存t的父亲 
		pre[t] = x;        // 直接指向最老祖先
		t = tFa;           // 下一个次级的没有指向最老祖先的 一直递推往上找
	}

	return x;
}

void Union(int a, int b) {
	a = Find(a);
	b = Find(b);

	//a,b的祖先一样，那么就不需要连接了
	if (a == b)
		return;

	// 注意这里接树的时候有遵循一个规则
	//a比b长，把b接到a树上 
	if (nodeNum[a] >= nodeNum[b]) {
		pre[b] = a;
		nodeNum[a] += nodeNum[b];
	}
	else {
		pre[a] = b;
		nodeNum[b] += nodeNum[a];
	}
}

bool Check(int x, int y) // 查找
{
	if (Find(x) == Find(y))
		return true;
	else
		return false;
}

int main() {
	scanf("%d%d", &n, &m);
	Init(n);
	for (i = 1; i <= m; i++)
		scanf("%d%d%d", &f[i].x, &f[i].y, &f[i].z);

	sort(f + 1, f + m + 1, cmp);

	// 运行到 m + 1, 条件满足, 让它直接输出零
	for (i = 1; i <= m + 1; i++) {
		if (Check(f[i].x, f[i].y)) { 
			printf("%d", f[i].z); 
			break;
		}							// 如果两个罪犯已经在同一监狱就输出 ，并退出
		else {
			if (!b[f[i].x])
				b[f[i].x] = f[i].y;	// 标记“敌人”
			else {
				Union(b[f[i].x], f[i].y); 
			}						// 将敌人的敌人合并
			if (!b[f[i].y])
				b[f[i].y] = f[i].x;
			else {
				Union(b[f[i].y], f[i].x);
			}
		}
	}
	return 0;
}

/*
题目描述</h2>
$S $城现有两座监狱，一共关押着$N $名罪犯，编号分别为$1-N$。他们之间的关系自然也极不和谐。很多罪犯之间甚至积怨已久，如果客观条件具备则随时可能爆发冲突。我们用“怨气值”（一个正整数值）来表示某两名罪犯之间的仇恨程度，怨气值越大，则这两名罪犯之间的积怨越多。如果两名怨气值为$c$ 的罪犯被关押在同一监狱，他们俩之间会发生摩擦，并造成影响力为$c $的冲突事件。</p>
每年年末，警察局会将本年内监狱中的所有冲突事件按影响力从大到小排成一个列表，然后上报到S 城Z 市长那里。公务繁忙的Z 市长只会去看列表中的第一个事件的影响力，如果影响很坏，他就会考虑撤换警察局长。</p>
在详细考察了$N$ 名罪犯间的矛盾关系后，警察局长觉得压力巨大。他准备将罪犯们在两座监狱内重新分配，以求产生的冲突事件影响力都较小，从而保住自己的乌纱帽。假设只要处于同一监狱内的某两个罪犯间有仇恨，那么他们一定会在每年的某个时候发生摩擦。</p>
那么，应如何分配罪犯，才能使Z 市长看到的那个冲突事件的影响力最小？这个最小值是多少？</p>
输入输出格式</h2>
输入格式：
每行中两个数之间用一个空格隔开。第一行为两个正整数$N,M$，分别表示罪犯的数目以及存在仇恨的罪犯对数。接下来的$M$行每行为三个正整数$a_j,b_j,c_j$，表示$a_j$ 号和$b_j $号罪犯之间存在仇恨，其怨气值为$c_j$。数据保证$1&lt;aj≤bj≤N ,0 &lt; cj≤ 1,000,000,000$，且每对罪犯组合只出现一次。


题面大意:（人性翻译）
给你m对矛盾关系,每对关系分别涉及到x，y两人,矛盾值为w

请你判断分配x和y到两个集合中，能否避免冲突

如能避免请输出0，如果冲突不可避免，请输出最小的矛盾值

以上是本人自己的“翻译”理解，接下来请看算法分析

输入输出样例
输入样例#1：
4 6
1 4 2534
2 3 3512
1 2 28351
1 3 6618
2 4 1805
3 4 12884

输出样例#1：
3512
*/