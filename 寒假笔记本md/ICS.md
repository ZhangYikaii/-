# ICS

[TOC]

## 注意点

NEMU模拟寄存器文件的代码位于 `nemu/include/cpu/reg.h`中. 对应于 CPU_STATE 这个头文件.

为模拟主存创建读写接口, 目的是为了对模块提供的功能进行封装, 以免其他外部模块直接接触内部模块的核心数据, 产生不可预料的后果.

## 零碎笔记 

ABI 是为运行在特定ISA以及特定操作系统之上的应用程序所遵循的一种机器级目标代码层接口规约.

性能评价主要了解: **CPI**

CPI各种计算, 要知道应该怎么算.



通用寄存器, (General Purpose Register)	程序计数器, (PC)

### 编译得到的汇编指令 & 反汇编得到的编译指令

差别:

- 编译得到的汇编指令带有长度后缀
- 编译得到的汇编指令常数用的是10进制, 而反汇编得到的是十六进制

### test.o: 可重定位目标文件   &   test: 可执行目标文件

test.o 中的代码从地址 0 开始, test 中的代码从 一个确切的地址( 虚拟地址)   (比如80483d4开始)

### 存储器操作数的寻址方式

Linux 系统: double 型变量按 4B 边界对齐, 4 的倍数才分配地址

### 小端方式

超过一个字节数据的存储规则: 低有效字节放在低地址, 高有效字节放在高地址.

### 存储关系

**`bit` 比特** , 最小, 存储一位 0 或者 1, 	

**`byte` 字节,** 字节由8 个比特构成, 是内存中可以遍址的最小单位.

**`word` 字**, 由 2 个字节, 16 个比特构成.

**`double word` 双字**, 由 4 个字节构成.





冒号 + 数字 表示占/分配几个比特... 前面写什么无所谓, 前面32位无符号整型, 后面 : 1 就是一个比特

union 后面后写的是高地址, 所以union里面那个要倒过来写

union 里面 val 和上面一堆的 uint32_t 是共用一块区域的



实际上用的时候 是全局变量, CPU_STATE cpu, 里面存储的就是实例化后的通用寄存器

如何访问通用寄存器, cpu.eflags.cf

初始化: cpu.eflags.val = 0;

模拟eflags, 实现ALU

cpu拿来计算和指令, device 模拟外部设备, 

进到cpu 里面有alu.c 要模拟实现各种运算, add( 就是实现加法 )

return 结果, 设置标志位

ifdef NEMU_REF_ALU  是给一个参考答案, 但是看不到源码

PA 1-2 就是实现 ALU里面的

找手册, 看手册里说的是什么

返回正确的运算结果



> 附录 C:
>
> 小横线 TM M 之类的意思在前面一点有.
>
> 前面一点还有具体OF, AF 之类要做什么

ADC: add with carry, 就是还要加上进位, 这样就有可能转一圈了, 比如CF = 1 和 dest 全 1 相加, 如果 CF = 1 的时候, 就多一种情况, 就是要 result <= src

真正起到作用的, 就是 cpu.eflags.    =   ... 之类的话



打开 alu.c 保存, 执行make编译, 必要的时候make clean, 执行测试.......



make 敲下去, 先去找Makefile, 冒号后面 有 nemu, 找到这个之后会 commit, 就是git里面的记录.然后出一个调查问卷.

然后就开始编译, 每换一行 然后 加一个 tab, 就是下面要做的途径.

单独加参数, 就是单独测试.	nemu下面有一个nemu可执行文件. 就是编译结果



追踪程序, main.c 就是不能动的, 一个空格都不可以加.

main里面: 先解析这个你的测试参数, 然后执行built-in, 内建的测试功能, 然后会去 test.c 里面做测试



## PA 1

 (0x1 << (data_size - 1))) && 0x1 判断 data_size 位上有没有 1, 其中 && 0x1 是为了把  (0x1 << (data_size - 1))) 转化为 0 或者 1.



## PA 2

struct 排在前面的是低地址.

### 浮点数加减:

> 对阶
>
> 阶码上溢: 最大阶码: 111111110  =>  254 - 127 = 127
>
> 阶码下溢: 最小阶码: 00000001  =>  1 - 127 = -126
>
> 尾数溢出:  右规 => 1.5 + 1.5 = 11000..00 改阶码, 小数点移动
>
> 非规格化尾数: 数值部分高位为 0, 就是那个隐含的 1 被搞掉了.

舍入也是异常情况.



## 课堂习题

### 1.2.1

unsinged short b[3] = { 0x1, 0x2, 0x3 };

注意是字节序, 0x02 0x00 这样子的

反码物理含义 x取负 => $2^{32} - x$



## PA 2

可执行文件 直接拷贝到内存为 0 开始的位置

可执行文件的镜像拷贝到 3000 位置的地方

0 ~ 3000这块地方是硬盘的地方 蓝色是可执行文件在硬盘上的镜像. 需要加载展开到内存里面.



进位的传递

$ ci+1 = ai\times bi+ai\times ci+bi\times ci $
            $   = ai\times bi+(ai+bi)\times ci$
            $   = gi+pi\times ci$
$gi=ai\times bi$称为进位生成因子, 只要gi为1, 就有进位
$pi=ai+bi$称为进位传递因子, 只要pi为1, 就有把低位的进位向前传递
四位进位传递为例
 $ c1 = g0+(p0\times c0) $
 $ c2 = g1+(p1\times g0)+(p1\times p0\times c0) $
$  c3 = g2+(p2\times g1)+(p2\times p1\times g0)+(p2\times p1\times p0\times c0)$
 $ c4 = g3+(p3\times g2)+(p3\times p2\times g1)+(p3\times p2\times p1\times g0)+(p3\times p2\times p1\times p0\times c0)$
只要低位有一个进位生成, 而且被传递, 则进位输出为1.





## Lab2

函数调用的时候 ebp 怎么跑下去的?

![1554810090657](C:\Users\Kai\AppData\Roaming\Typora\typora-user-images\1554810090657.png)

这种可以直接看到 0x8(%ebp) 是多少吗.

递归phase, 到了函数里面, 三个参数被放在了哪里.







## 上课

main.o 里面会分配空间, 这就是定义, 编译器会分配空间.



void swap();

高级语言里面是声明, 这个不是定义也不是引用.

对函数的引用是 call 语句出现, 就是调用处

真正初始化了值才会分配空间?





![1558506085050](C:\Users\Kai\AppData\Roaming\Typora\typora-user-images\1558506085050.png)

这里PDE是页表的页目录, PTE是真正的页表项.

分页模式开关, cr0 的PG位

![1558506239421](C:\Users\Kai\AppData\Roaming\Typora\typora-user-images\1558506239421.png)

从上面这里开始才开启分页机制.

课本上讲了DRAM的构造.



有一个$TLB$ 和 $L1$ 的data cache. 虚拟地址16位, 物理地址12位, 不考虑分段, 页大小 128B , TLB 4路组相联, 16个页表项, $L1$ data cache 直接映射, 块大小 4 B, 共 16 行, 运行的某时刻,  给出了

