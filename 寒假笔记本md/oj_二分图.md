# 二分图

## 二分图的定义：

如果一张**无向图**的n个节点`(n >= 2)`可以分为A,B两个集合，且满足A ∩ B = ∅ ，而且在**同一集合内的点之间都没有边相连**，那么这张无向图被称为二分图，其中 A 和 B 分别叫做二分图的左部和右部

简单来说，如果图中点可以被分为两组，并且使得所有边都跨越组的边界，则这就是一个二分图

**二分图的一个等价定义是：不含有「含奇数条边的环」的图.**

**匹配**：在图论中，一个「匹配」（matching）是一个边的集合，其中任意两条边都没有公共顶点。

**最大匹配**：一个图所有匹配中，所含匹配边数最多的匹配，称为这个图的最大匹配

**完美匹配**：如果一个图的某个匹配中，所有的顶点都是匹配点，那么它就是一个完美匹配



## 例题

1525 关押罪犯

**二分图判定定理**：

> 一张无向图是二分图：当且仅当图中不存在奇环（奇环是指长度为奇数的环）

结合**染色法**判定是不是二分图: 用黑色和白色标记图中的点, 当一个节点被标记了，那么**所有与它相连的点应全部标记为相反的颜色**, dfs / bfs.

如何求最小矛盾值?

考虑这样一个判定问题：是否存在一种分配方案，使得最小的矛盾值不超过mid。显然，当mid较小时可行的方案对于mid较大时依然可行。换言之，**本题的答案具有单调性**，**可以采用二分的方法求解**，**将求最小值问题转换为判定问题**

策略如下：我们**二分答案**，设当前二分的值为mid，此时任意两个矛盾双方 x 和 y 必须被分在两个不同集合中，将罪犯们作为节点，**在矛盾值大于等于mid的罪犯之间连一条边 ( 这是关键!!! )**，我们得到一张无向图。此时我们**只需判定这张无向图是否为二分图**即可（因为要分为两部分），**如果是二分图，令二分右端点R = mid，否则令L = mid即可**



> ```
> 染色法判定是不是二分图的bfs方法:
> 首先我们枚举每一个点，如果这个点没有染色，那么我们开始我们的算法。首先把这个点标记成黑色，然后开始bfs，枚举所有与它相连的点，将它们标记成白色，不断遍历整张图，如果你发现下一个染色的点已经有了颜色，判断是否与此时你在的点颜色一致。若是颜色一致，说明染色存在冲突，无法拆成二分图，直接return false。如果无误，直到队列为空退出（注意只有没染色的点才需要加入队列）。之后我们枚举下一个点，若已染色则跳过，没有的话说明我们找到了一张新的图，接下来我们只需要重复上面的步骤就行了。
> ```



## 精妙的存图方法(可以轻松用遍历边去访问邻接的点)

```c++
// 这种存两次的像有向边的方法! from 连接的是边, to连接的是点
void AddEdge(int x, int y, int W) {
	cnt++;
	edge[cnt].from = head[x];
	head[x] = cnt;		// 存着这个点连接的边的编号, 下一次另一条边(含有这个点的)进来可以连接上这条边
	edge[cnt].to = y;
	edge[cnt].w = W;
}

// 然后main函数里加边方法:
// 加边（无向图）
	for (int i = 1; i <= m; i++) {
		int x = read(), y = read(), w = read();
		R = max(R, w);//二分右端点 
		AddEdge(x, y, w);
		AddEdge(y, x, w);
	}


// 访问邻接点时!!!
// x是最开始的点, 这样遍历的i就都是连接着x的, edge[i].to 就是邻接的点了!!!
for (int i = head[x]; i != 0; i = edge[i].from) {

```

