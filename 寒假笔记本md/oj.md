# OJ 笔记

[TOC]

## 二分图：

**定义:** 如果一张**无向图**的n个节点`(n >= 2)`可以分为A,B两个集合，且满足A ∩ B = ∅ ，而且在**同一集合内的点之间都没有边相连**，那么这张无向图被称为二分图，其中 A 和 B 分别叫做二分图的左部和右部

简单来说，如果图中点可以被分为两组，并且使得所有边都跨越组的边界，则这就是一个二分图

**二分图的一个等价定义是：不含有「含奇数条边的环」的图.**

**匹配**：在图论中，一个「匹配」（matching）是一个边的集合，其中任意两条边都没有公共顶点。

**最大匹配**：一个图所有匹配中，所含匹配边数最多的匹配，称为这个图的最大匹配

**完美匹配**：如果一个图的某个匹配中，所有的顶点都是匹配点，那么它就是一个完美匹配



### 例题

1525 关押罪犯

**二分图判定定理**：

> 一张无向图是二分图：当且仅当图中不存在奇环（奇环是指长度为奇数的环）

结合**染色法**判定是不是二分图: 用黑色和白色标记图中的点, 当一个节点被标记了，那么**所有与它相连的点应全部标记为相反的颜色**, dfs / bfs.

如何求最小矛盾值?

考虑这样一个判定问题：是否存在一种分配方案，使得最小的矛盾值不超过mid。显然，当mid较小时可行的方案对于mid较大时依然可行。换言之，**本题的答案具有单调性**，**可以采用二分的方法求解**，**将求最小值问题转换为判定问题**

策略如下：我们**二分答案**，设当前二分的值为mid，此时任意两个矛盾双方 x 和 y 必须被分在两个不同集合中，将罪犯们作为节点，**在矛盾值大于等于mid的罪犯之间连一条边 ( 这是关键!!! )**，我们得到一张无向图。此时我们**只需判定这张无向图是否为二分图**即可（因为要分为两部分），**如果是二分图，令二分右端点R = mid，否则令L = mid即可**



> ```
> 染色法判定是不是二分图的bfs方法:
> 首先我们枚举每一个点，如果这个点没有染色，那么我们开始我们的算法。首先把这个点标记成黑色，然后开始bfs，枚举所有与它相连的点，将它们标记成白色，不断遍历整张图，如果你发现下一个染色的点已经有了颜色，判断是否与此时你在的点颜色一致。若是颜色一致，说明染色存在冲突，无法拆成二分图，直接return false。如果无误，直到队列为空退出（注意只有没染色的点才需要加入队列）。之后我们枚举下一个点，若已染色则跳过，没有的话说明我们找到了一张新的图，接下来我们只需要重复上面的步骤就行了。
> ```



### 精妙的存图方法(可以轻松用遍历边去访问邻接的点)

```c++
// 这种存两次的像有向边的方法! from 连接的是边, to连接的是点
void AddEdge(int x, int y, int W) {
	cnt++;
	edge[cnt].from = head[x];
	head[x] = cnt;		// 存着这个点连接的边的编号, 下一次另一条边(含有这个点的)进来可以连接上这条边
	edge[cnt].to = y;
	edge[cnt].w = W;
}

// 然后main函数里加边方法:
// 加边（无向图）
	for (int i = 1; i <= m; i++) {
		int x = read(), y = read(), w = read();
		R = max(R, w);//二分右端点 
		AddEdge(x, y, w);
		AddEdge(y, x, w);
	}


// 访问邻接点时!!!
// x是最开始的点, 这样遍历的i就都是连接着x的, edge[i].to 就是邻接的点了!!!
for (int i = head[x]; i != 0; i = edge[i].from) {

```

原来上面的精妙存图方式是: **链式前向星**

## 链式前向星

### 结构

```c++
struct Edge {
	int next;	// 下一条边的下标(默认为0)
	int to;		// 这条边的终点
	int w;		// 这条边的权值
};
```

### 增边

```c++
int cnt = 0;
void Add(int u, int v, int w) {		// 起点u, 终点v, 权值w 
	// 前两句是为了连接起整个图的
	edge[++cnt].next = head[u];
	head[u] = cnt;				   // 为下一次 next 连接做准备

	edge[cnt].w = w;
	edge[cnt].to = v;
}
```

### 遍历

```c++
// i 开始为第一条边，每次指向下一条 (其实是输入顺序的上一条) (以 0 为结束标志)
// 若下标从 0 开始，next 应初始化 -1 ! (不要这样做/xk)
for (int i = head[start]; i != 0; i = edge[i].next)
```

**一定要好好理解!!! `head[]` 沟通了 点(下标 `i`) 和 边(`head[i]`)**`head[i] 存的是连接 i 点 ( 而且 i 是起点的下标) 的 最后输入的 边, 然后找其他边可以通过 edge[i].next 去找前面输入的边`, 

`start`就是开始的点的下标, 点要从 `1` 开始存

## 动规提高

### 例题 1052 过河之路径压缩: 这题主要就是路径压缩, 还未懂...

目的是要找到两石同相隔较长时直接缩短的方法

假设每次走p或者p+1步.我们知道$\gcd(p,p+1)=1.$

由**扩展欧几里得**( [扩展欧几里德算法]是用来在已知a, b求解一组x，y，使它们满足贝祖等式： ax+by = gcd(a, b) =d（解一定存在，根据[数论]中的相关定理）)可知，对于二元一次方程组：

$px+(p+1)y=\gcd(p,p+1)​$是有整数解的，即可得：$px+(p+1)y=s​$是一定有整数解的.

设$px+(p+1)y=s$的解为：$x=x0+(p+1)t,y=y0-pt$。令$0<=x<=p$(通过增减$t个p+1$来实现)，$s>p*(p+1)-1$,

则有：

$y=\frac{s-px}{p+1}>=\frac{s-p^2}{p+1}>\frac{p*(p+1)-1-px}{p+1} >= 0​$

即表示，当 $s>=p*(p+1)$ 时，$px+(p+1)y=s$ 有两个非负整数解，每次走p步或者 $p+1$ 步，$p*(p+1)​$ 之后的地方均能够到达。

如果两个石子之间的距离大于 $p*(p+1)​$ ，那么就可以直接将他们之间的距离更改为 $p*(p+1)​$ 

**综上，得到压缩路径的方法：若两个石子之间的距离大于 $t*(t-1)$ ，则将他们的距离更改为 $t*(t-1)$ .**

因为 $t<=10​$ ，因此我们可以直接将大于10*9的距离直接化为90.

但是要注意，对于 $s=t$ 这种特殊情况，这种方法是不成立的, 因为在这种情况下，每次是不能够走p+1步的，因此需要另外特殊判断。

方程如下:

$f[i]=f[i-1]+(i \mod s ==0)$



### 区间dp

#### 1220关路灯

可以得到两种状态（沿着当前方向继续往下走，改变方向回去关灯）, **又因为如果想要关某一区间的灯的过程中耗能最小，所以可以转换成一个个区间来写：** 

> 去关某一区间的灯，那么整条街道上除了这一区间的灯会逐渐灭掉其他肯定会全亮; 那么我们把`f[i][j]`记为当从 `i 到 j` 的灯都熄灭后剩下的灯的总功率。

再进一步：`f[i][j][0]`表示关掉`i到j`的灯后，老张站在左端点，f[i][j][1]表示关掉后,老张站在右端点

（i为左端点，j为右端点）

### 数学类也可以有dp

![1550199115846](C:\Users\Kai\AppData\Roaming\Typora\typora-user-images\1550199115846.png)

`状态转移方程: dp[n][m] = dp[n-1][m] + dp[n][m-1] - dp[n-1][m-1] `,

`dp[n-1][m-1]`用来去重, 因为 `n - 1, m - 1` 这个点被加了两次

`换句话说，dp[n][m] = dp[n-1][m-1] + C(n,m-1)新增量 + C(n-1,m）新增量。`

### 难理解的动规

**题目描述**

小明的花店新开张，为了吸引顾客，他想在花店的门口摆上一排花，共*m*盆。通过调查顾客的喜好，小明列出了顾客最喜欢的*n*种花，从1到*n*标号。为了在门口展出更多种花，规定第*i*种花不能超过$a_i​$盆，摆花时同一种花放在一起，且不同种类的花需按标号的从小到大的顺序依次摆列。

试编程计算，一共有多少种不同的摆花方案。

![1550238921496](C:\Users\Kai\AppData\Roaming\Typora\typora-user-images\1550238921496.png)



## 记忆化搜索

记忆化搜索 = 搜索的形式 + 动态规划的思想

### 1005矩阵取数

思路: 按行进行**区间DP**，我们可以设区间`[L,R]`的最大值为$f[L][R]$,用一个数组$p[n]$来储存$2^n$的值,采用**记忆化搜索**的办法,

设**k=m-(R-L)**,可以得到状态转移方程:$f[L][R]=max(num[L] \times p[k]+dp(L+1,R),   dp(L,R-1)+num[R] \times p[k])$
即选掉开头的那个, 和选掉末位的那个, 注意**要有递推如何进行的思想!**

```c++
#define k (m-(R-L)) // k: 当前选取次数, m: 每行个数

// 本质就是一个dfs/递归搜索
int dp(int L, int R) {
	// 如果答案的结点被更新了说明已经有答案了, 剪枝
	if (f[L][R] != -1)
		return f[L][R];
	if (R - L >= 1) 
		f[L][R] = max(num[L] * p[k] + dp(L + 1, R), dp(L, R - 1) + num[R] * p[k]);
	// 只有一个的时候
	else
		f[L][R] = num[L] * p[k];
	return f[L][R];
}
```

## 树形DP

树形DP的这一特殊性： 没有环，dfs是不会重复，而且具有明显而又严格的层数关系。 利用这一特性，我们可以很清晰地根据题目写出一个在树（型结构）上的记忆化搜索的程序。而深搜的特点，就是“不撞南墙不回头”

### DAG上的动规( 算法入门经典 )

有向无环图上的动规是学习动规的基础, 

>  **嵌套矩形问题**: 两个整数 a, b 表示长和宽, (1, 5) 可以嵌套在(6, 2) 之内, 但不能嵌套在 (3, 4) 内, 选出尽可能多的矩形排成一行, 除了最后一个之外每一个矩形都可以嵌套在下一个矩形之内, 矩形编号的字典序应该尽量小
>
> 如果 x 可以嵌套在 y 里面, 就从 x 连一条有向边到 y. 这个有向图是无环的(自己思考) => 求这个DAG图的最长路径.



## 组合数递推法打表

![1550198957673](C:\Users\Kai\AppData\Roaming\Typora\typora-user-images\1550198957673.png)

组合数递推法
针对大多数仅仅是利用组合数求解问题的题目运用递推法打表，不仅方便，而且可以稳稳地控制复杂度，对于需要多次引用组合数的题目效果极佳:

由 $ C^m_n = \frac{n!}{m!(n-m)!}$
推得：$ C^m_n=C^{m-1}_{n-1}+C^{m-1}_n​$

由这个递推公式就可以熟练的写出组合数代码，但要**注意初始化:**
$C^0_0=1$
$C^i_0=C^1_0=C^1_1=1$ ( $i$为自然数 )

同时，把表打出来后，我们会发现———这就是杨辉三角，这个三角可以解决很多问题，记住打印三角的方法也可以打出组合数

```c++
const int MAXN = 2000;
inline void Init() {
    // 初始化
    c[0][0] = 1;
    c[1][0] = 1;
    c[1][1] = 1;
    for (int i = 2; i < MAXN; ++i) {
        c[i][0] = 1;
        for (int k = 1; k <= i; ++k) {
            // 递归
            c[i][k] = c[i][k - 1] + c[i - 1][k - 1];
        }
    }
}
```



## 前缀和与差分

### 一维前缀和

```c++
// 前缀和
a[0] = 0;
for(int i = 1; i <= n; ++i)
	a[i] += a[i-1];
```

**前缀和顾名思义就是前面 i 个数的总和**

#### 差分

**例题理解:** 给你一串长度为n的数列$a_1,a_2,a_3......a_n，$要求对$a[L]~a[R]$进行$m$次操作：

**操作一：**将a[L]~a[R]内的元素都加上P

**操作二：**将a[L]~a[R]内的元素都减去P

最后再给出一个询问求 a[L]~a[R] 内的元素之和？

差分方法: **新开一个数组b，储存每一次的修改操作，最后求前缀和的时候统计一下就能快速的得到正确答案了**，

```c++
#include<bits/stdc++.h>
using namespace std;
const int maxn = 1e5 + 9;
int a[maxn], b[maxn];
int main(){
	int i, j, k, n, m, p;
	cin >> n >> m;
	for (i = 1; i <= n; i++){
		cin >> a[i];
	}
    // m 次操作
	for (i = 1; i <= m; i++){
		int L, R, t;
		cin >> t >> L >> R >> p;
		if (t == 1) {
            b[L] += p; 
            b[R + 1] -= p;	// 注意这句话!!! b[L] 就是一个开始加的标志位( 结合下面add += b[i]理解 ) 在 R + 1 之后的位置, 要取消这个加的标志位, 所以要 b[R + 1] -= p;
		}
		else{
			b[L] -= p; b[R + 1] += p;
		}
	}
	int add = 0;
	for (i = 1; i <= n; i++){
		add += b[i];			// L ~ R +p 只有b[L] == p, b[R + 1] == -p, 注意因为add += b[L] 之后, 后面的都会有影响, 都会加上去 => 这一段前缀和都有 +p.
		a[i] += a[i - 1] + add;
	}
	int x, y;
	cin >> x >> y;
	cout << a[y] - a[x - 1] << endl;
}
```

### 二维前缀和

**例题:**  给定一个n\*m大小的矩阵a，有q次询问，每次询问给定x1,y1,x2,y2四个数，求以(x1,y1)为左上角坐标和(x2,y2)为右下角坐标的子矩阵的所有元素和。注意仍然包含左上角和右下角的元素。

**`a[i][j]` 表示的是以 `a[i][j]` 为最右下点的左上方矩阵的和**

```c
// 二维前缀和
for (int i = 1; i <= n; i++) {
	for (int j = 1; j <= m; j++)
		a[i][j] += a[i][j - 1] + a[i - 1][j] - a[i - 1][j - 1];		// a[i - 1][j - 1] 加了两遍
}
```

![1550201501527](C:\Users\Kai\AppData\Roaming\Typora\typora-user-images\1550201501527.png)

#### 差分:

```c
for (int i = 0; i<m; i++){	// m 是修改操作次数 
	int x1, y1, x2, y2, p;
	cin >> x1 >> y1 >> x2 >> y2 >> p;
	b[x1][y1] += p; b[x2 + 1][y2 + 1] += p;
	b[x2 + 1][y1] -= p; b[x1][y2 + 1] -= p;
}
```

## 贪心

**贪心时常很牛逼!**

**题目描述**

2020年，人类在火星上建立了一个庞大的基地群，总共有n个基地。起初为了节约材料，人类只修建了n-1条道路来连接这些基地，并且每两个基地都能够通过道路到达，所以所有的基地形成了一个巨大的树状结构。如果基地A到基地B至少要经过d条道路的话，我们称基地A到基地B的距离为d。
由于火星上非常干燥，经常引发火灾，人类决定在火星上修建若干个消防局。消防局只能修建在基地里，每个消防局有能力扑灭与它距离不超过2的基地的火灾。
你的任务是计算至少要修建多少个消防局才能够确保火星上所有的基地在发生火灾时，消防队有能力及时扑灭火灾。

**思路:**

**树形的**, 考虑当前深度最大的叶子结点，你肯定要有一个消防局去覆盖它，那么既然他是叶子结点，所以与他距离小于等于2的节点有这么几种：

1. 他的父亲 
2. 他的兄弟 
3. 他的爷爷

容易看出，在前两项能够覆盖到的节点，在爷爷那里设立一定也能覆盖到。所以每次贪心取出深度最大的节点，在他的爷爷那里放一个消防站

```c++
// 题解1
// 树还可以这样表示! 注意输入格式 和 deep[], index[] 的结合
#include<iostream>
#include<cstdio>
#include<algorithm>
#define N 2020
#define FOR(i,a,b) for(int i=a;i<=b;i++)
using namespace std;
int n, index[N], f[N], deep[N], dp[N], ans, grand, child, fathe;

// 又出现的这样的排序方式!!!
bool cmp(int x, int y) {
	return deep[x] > deep[y];
}

// dp[i] 是第 i 个结点离最近消防站的距离
int main() {
	scanf("%deep", &n); 
	index[1] = 1, dp[1] = dp[0] = N;
	FOR(i, 2, n) {
		scanf("%deep", &f[i]);
		// 计算深度
		deep[i] = deep[f[i]] + 1;
		index[i] = i;    // 存下标
		dp[i] = N;	 // 初始化
	}

	// index[i] 就是 deep[]深度数组的下标, 我们只需要下标 ( 就是点的坐标 )
	sort(index + 1, index + n + 1, cmp);

	// 有点像dp咯
	FOR(i, 1, n) {
		// 从深度最大的结点开始, 就是 index[] 的排序
		child = index[i], fathe = f[child], grand = f[f[child]];
		// 更新
		dp[child] = min(dp[child], min(dp[fathe] + 1, dp[grand] + 2));
		// 把爷爷结点设置为消防站
		if (dp[child] > 2) {
			dp[grand] = 0;
			++ans;
			// 更新
			dp[f[grand]] = min(dp[f[grand]], 1);
			dp[f[f[grand]]] = min(dp[f[f[grand]]], 2);
		}
	}
	
	printf("%deep", ans);

	return 0;
}
```



## AC自动机

~~挑战一下~~
https://www.cnblogs.com/cmmdc/p/7337611.html

`Aho-Corasick automation`是著名的**多模匹配算法**之一。一个常见的例子就是给出n个单词，再给出一段包含m个字符的文章，让你找出有多少个单词在文章里出现过。

**AC自动机和字典树的关系比较大，所以先来简单的了解下字典树Trie树**。

字典树又称单词查找树，Trie树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的**优点**是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。

简而言之：字典树就是像平时使用的字典一样的，我们把所有的单词编排入一个字典里面，**当我们查找单词的时候，**我们首先看单词首字母，进入首字母所再的树枝，然后看第二个字母，再进入相应的树枝，假如该单词再字典树中存在，那么我们只用花费单词长度的时间查询到这个单词。

**AC自动机关键点一：字典树的构建过程：**

字典树的构建过程是这样的，当要插入许多单词的时候，我们要从前往后遍历整个字符串，

1. 当我们发现当前要插入的字符其节点再先前已经建成，我们直接去考虑下一个字符即可

2. 当我们发现当前要插入的字符没有再其前一个字符所形成的树下没有自己的节点，我们就要创建一个新节点来表示这个字符，接下往下遍历其他的字符。然后重复上述操作。

注意开头字符都在 root 下一层

![1550224673853](C:\Users\Kai\AppData\Roaming\Typora\typora-user-images\1550224673853.png)

**AC自动机关键点二：找Fail指针**

在KMP算法中，当我们比较到一个字符发现失配的时候我们会通过next数组，找到下一个开始匹配的位置，然后进行字符串匹配，当然KMP算法试用于**单模式匹配**，所谓单模式匹配，就是给出一个模式串，给出一个文本串，然后看模式串在文本串中是否存在。

**在AC自动机中，我们也有类似next数组的东西就是fail指针**，当发现失配的字符失配的时候，跳转到fail指针指向的位置，然后再次进行匹配操作，**AC自动机之所以能实现多模式匹配，就归功于Fail指针的建立。**

当前节点 t 有 fail 指针，其 fail 指针所指向的节点**和 t 所代表的字符是相同的。**
因为t匹配成功后，我们需要去匹配`t->child`，发现失配，那么就从 `t->fail` 这个节点开始再次去进行匹配。

**Fail指针的求法：**
Fail指针用BFS来求得，对于直接与根节点相连的节点来说，如果这些节点失配，他们的Fail指针直接指向root即可，其他节点其Fail指针求法如下：

>- 假设当前节点为father，其孩子节点记为child。求child的Fail指针时，首先我们要找到其father的Fail指针所指向的节点,
>- 假如是 t 的话，我们就要看 t 的孩子中有没有和child节点所表示的字母相同的节点，
>- - 如果有的话，这个节点就是child的fail指针，
>  - - 如果发现没有，则需要找father->fail->fail这个节点，然后重复上面过程，如果一直找都找不到，则child的Fail指针就要指向root。

**实例 ( 有颜色的就是 fail 指针 ):**

![1550225206126](C:\Users\Kai\AppData\Roaming\Typora\typora-user-images\1550225206126.png)

如图所示，首先root最初会进队，然后root,出队，我们把root的孩子的失败指针都指向root。因此图中h,s的失败指针都指向root, 如红色线条所示，同时h,s进队。

接下来该h出队，我们就找h的孩子的fail指针，首先我们发现h这个节点其fail指针指向root,而root又没有字符为e的孩子，则e的fail指针是空的，如果为空，则也要指向root,如图中蓝色线所示。并且e进队，此时s要出队，我们再找s的孩子a,h的fail指针，
我们发现s的fail指针指向root,而root没有字符为a的孩子，故a的
fail指针指向root，a入队，然后找h的fail指针，同样的先看s的fail指针是root，发现root又字符为h的孩子，所以h的fail指针就指向了第二层的h节点。e，a , h 的fail指针的指向如图蓝色线所示。

此时队列中有e,a,h，e先出队，找e的孩子r的失败指针，我们先看e的失败指针，发现找到了root,root没有字符为r
的孩子，则r的失败指针指向了root,并且r进队，然后a出队，我们也是先看a的失败指针，发现是root,则y的fail指针就会指向root.并且y进队。然后h出队，考虑h的孩子e,则我们看h的失败指针，指向第二层的h节点，看这个节点发现有字符值为e的节点，最后一行的节点e的失败指针就指向第三层的e。最后找r的指针，同样看第二层的h节点，其孩子节点不含有字符r，则会继续往前找h的失败指针找到了根，根下面的孩子节点也不存在有字符r，则最后r就指向根节点，最后一行节点的fail指针如绿色虚线所示。