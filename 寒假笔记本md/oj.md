# OJ 笔记

[TOC]

## 二分图：

**定义:** 如果一张**无向图**的n个节点`(n >= 2)`可以分为A,B两个集合，且满足A ∩ B = ∅ ，而且在**同一集合内的点之间都没有边相连**，那么这张无向图被称为二分图，其中 A 和 B 分别叫做二分图的左部和右部

简单来说，如果图中点可以被分为两组，并且使得所有边都跨越组的边界，则这就是一个二分图

**二分图的一个等价定义是：不含有「含奇数条边的环」的图.**

**匹配**：在图论中，一个「匹配」（matching）是一个边的集合，其中任意两条边都没有公共顶点。

**最大匹配**：一个图所有匹配中，所含匹配边数最多的匹配，称为这个图的最大匹配

**完美匹配**：如果一个图的某个匹配中，所有的顶点都是匹配点，那么它就是一个完美匹配



### 例题

1525 关押罪犯

**二分图判定定理**：

> 一张无向图是二分图：当且仅当图中不存在奇环（奇环是指长度为奇数的环）

结合**染色法**判定是不是二分图: 用黑色和白色标记图中的点, 当一个节点被标记了，那么**所有与它相连的点应全部标记为相反的颜色**, dfs / bfs.

如何求最小矛盾值?

考虑这样一个判定问题：是否存在一种分配方案，使得最小的矛盾值不超过mid。显然，当mid较小时可行的方案对于mid较大时依然可行。换言之，**本题的答案具有单调性**，**可以采用二分的方法求解**，**将求最小值问题转换为判定问题**

策略如下：我们**二分答案**，设当前二分的值为mid，此时任意两个矛盾双方 x 和 y 必须被分在两个不同集合中，将罪犯们作为节点，**在矛盾值大于等于mid的罪犯之间连一条边 ( 这是关键!!! )**，我们得到一张无向图。此时我们**只需判定这张无向图是否为二分图**即可（因为要分为两部分），**如果是二分图，令二分右端点R = mid，否则令L = mid即可**



> ```
> 染色法判定是不是二分图的bfs方法:
> 首先我们枚举每一个点，如果这个点没有染色，那么我们开始我们的算法。首先把这个点标记成黑色，然后开始bfs，枚举所有与它相连的点，将它们标记成白色，不断遍历整张图，如果你发现下一个染色的点已经有了颜色，判断是否与此时你在的点颜色一致。若是颜色一致，说明染色存在冲突，无法拆成二分图，直接return false。如果无误，直到队列为空退出（注意只有没染色的点才需要加入队列）。之后我们枚举下一个点，若已染色则跳过，没有的话说明我们找到了一张新的图，接下来我们只需要重复上面的步骤就行了。
> ```



### 精妙的存图方法(可以轻松用遍历边去访问邻接的点)

```c++
// 这种存两次的像有向边的方法! from 连接的是边, to连接的是点
void AddEdge(int x, int y, int W) {
	cnt++;
	edge[cnt].from = head[x];
	head[x] = cnt;		// 存着这个点连接的边的编号, 下一次另一条边(含有这个点的)进来可以连接上这条边
	edge[cnt].to = y;
	edge[cnt].w = W;
}

// 然后main函数里加边方法:
// 加边（无向图）
	for (int i = 1; i <= m; i++) {
		int x = read(), y = read(), w = read();
		R = max(R, w);//二分右端点 
		AddEdge(x, y, w);
		AddEdge(y, x, w);
	}


// 访问邻接点时!!!
// x是最开始的点, 这样遍历的i就都是连接着x的, edge[i].to 就是邻接的点了!!!
for (int i = head[x]; i != 0; i = edge[i].from) {

```

原来上面的精妙存图方式是: **链式前向星**

## 链式前向星

### 结构

```c++
struct Edge {
	int next;	// 下一条边的下标(默认为0)
	int to;		// 这条边的终点
	int w;		// 这条边的权值
};
```

### 增边

```c++
int cnt = 0;
void Add(int u, int v, int w) {		// 起点u, 终点v, 权值w 
	// 前两句是为了连接起整个图的
	edge[++cnt].next = head[u];
	head[u] = cnt;				   // 为下一次 next 连接做准备

	edge[cnt].w = w;
	edge[cnt].to = v;
}
```

### 遍历

```c++
// i 开始为第一条边，每次指向下一条 (其实是输入顺序的上一条) (以 0 为结束标志)
// 若下标从 0 开始，next 应初始化 -1 ! (不要这样做/xk)
for (int i = head[start]; i != 0; i = edge[i].next)
```

**一定要好好理解!!! `head[]` 沟通了 点(下标 `i`) 和 边(`head[i]`)**`head[i] 存的是连接 i 点 ( 而且 i 是起点的下标) 的 最后输入的 边, 然后找其他边可以通过 edge[i].next 去找前面输入的边`, 

`start`就是开始的点的下标, 点要从 `1` 开始存

## 动规提高

### 例题 1052 过河之路径压缩: 这题主要就是路径压缩, 还未懂...

目的是要找到两石同相隔较长时直接缩短的方法

假设每次走p或者p+1步.我们知道$\gcd(p,p+1)=1.$

由**扩展欧几里得**( [扩展欧几里德算法]是用来在已知a, b求解一组x，y，使它们满足贝祖等式： ax+by = gcd(a, b) =d（解一定存在，根据[数论]中的相关定理）)可知，对于二元一次方程组：

$px+(p+1)y=\gcd(p,p+1)​$是有整数解的，即可得：$px+(p+1)y=s​$是一定有整数解的.

设$px+(p+1)y=s$的解为：$x=x0+(p+1)t,y=y0-pt$。令$0<=x<=p$(通过增减$t个p+1$来实现)，$s>p*(p+1)-1$,

则有：

$y=\frac{s-px}{p+1}>=\frac{s-p^2}{p+1}>\frac{p*(p+1)-1-px}{p+1} >= 0​$

即表示，当 $s>=p*(p+1)$ 时，$px+(p+1)y=s$ 有两个非负整数解，每次走p步或者 $p+1$ 步，$p*(p+1)​$ 之后的地方均能够到达。

如果两个石子之间的距离大于 $p*(p+1)​$ ，那么就可以直接将他们之间的距离更改为 $p*(p+1)​$ 

**综上，得到压缩路径的方法：若两个石子之间的距离大于 $t*(t-1)$ ，则将他们的距离更改为 $t*(t-1)$ .**

因为 $t<=10​$ ，因此我们可以直接将大于10*9的距离直接化为90.

但是要注意，对于 $s=t$ 这种特殊情况，这种方法是不成立的, 因为在这种情况下，每次是不能够走p+1步的，因此需要另外特殊判断。

方程如下:

$f[i]=f[i-1]+(i \mod s ==0)$



### 类区间dp 1005矩阵取数

思路: 按行进行区间DP，我们可以设区间[L,R]的最大值为$f[L][R]$,用一个数组$p[n]$来储存$2^n$的值,采用**记忆化搜索**的办法,

设**k=m-(R-L)**,可以得到状态转移方程:$f[L][R]=max(num[L] \times p[k]+dp(L+1,R),   dp(L,R-1)+num[R] \times p[k])$
即选掉开头的那个, 和选掉末位的那个, 注意**要有递推如何进行的思想!**



## 记忆化搜索

记忆化搜索 = 搜索的形式 + 动态规划的思想

```c++
#define k (m-(R-L)) // k: 当前选取次数, m: 每行个数

// 本质就是一个dfs/递归搜索
int dp(int L, int R) {
	// 如果答案的结点被更新了说明已经有答案了, 剪枝
	if (f[L][R] != -1)
		return f[L][R];
	if (R - L >= 1) 
		f[L][R] = max(num[L] * p[k] + dp(L + 1, R), dp(L, R - 1) + num[R] * p[k]);
	// 只有一个的时候
	else
		f[L][R] = num[L] * p[k];
	return f[L][R];
}
```

## 树形DP

树形DP的这一特殊性： 没有环，dfs是不会重复，而且具有明显而又严格的层数关系。 利用这一特性，我们可以很清晰地根据题目写出一个在树（型结构）上的记忆化搜索的程序。而深搜的特点，就是“不撞南墙不回头”

