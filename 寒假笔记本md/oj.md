# OJ 笔记

[TOC]

## 二分图：

**定义:** 如果一张**无向图**的n个节点`(n >= 2)`可以分为A,B两个集合，且满足A ∩ B = ∅ ，而且在**同一集合内的点之间都没有边相连**，那么这张无向图被称为二分图，其中 A 和 B 分别叫做二分图的左部和右部

简单来说，如果图中点可以被分为两组，并且使得所有边都跨越组的边界，则这就是一个二分图

**二分图的一个等价定义是：不含有「含奇数条边的环」的图.**

**匹配**：在图论中，一个「匹配」（matching）是一个边的集合，其中任意两条边都没有公共顶点。

**最大匹配**：一个图所有匹配中，所含匹配边数最多的匹配，称为这个图的最大匹配

**完美匹配**：如果一个图的某个匹配中，所有的顶点都是匹配点，那么它就是一个完美匹配



### 例题

1525 关押罪犯

**二分图判定定理**：

> 一张无向图是二分图：当且仅当图中不存在奇环（奇环是指长度为奇数的环）

结合**染色法**判定是不是二分图: 用黑色和白色标记图中的点, 当一个节点被标记了，那么**所有与它相连的点应全部标记为相反的颜色**, dfs / bfs.

如何求最小矛盾值?

考虑这样一个判定问题：是否存在一种分配方案，使得最小的矛盾值不超过mid。显然，当mid较小时可行的方案对于mid较大时依然可行。换言之，**本题的答案具有单调性**，**可以采用二分的方法求解**，**将求最小值问题转换为判定问题**

策略如下：我们**二分答案**，设当前二分的值为mid，此时任意两个矛盾双方 x 和 y 必须被分在两个不同集合中，将罪犯们作为节点，**在矛盾值大于等于mid的罪犯之间连一条边 ( 这是关键!!! )**，我们得到一张无向图。此时我们**只需判定这张无向图是否为二分图**即可（因为要分为两部分），**如果是二分图，令二分右端点R = mid，否则令L = mid即可**



> ```
> 染色法判定是不是二分图的bfs方法:
> 首先我们枚举每一个点，如果这个点没有染色，那么我们开始我们的算法。首先把这个点标记成黑色，然后开始bfs，枚举所有与它相连的点，将它们标记成白色，不断遍历整张图，如果你发现下一个染色的点已经有了颜色，判断是否与此时你在的点颜色一致。若是颜色一致，说明染色存在冲突，无法拆成二分图，直接return false。如果无误，直到队列为空退出（注意只有没染色的点才需要加入队列）。之后我们枚举下一个点，若已染色则跳过，没有的话说明我们找到了一张新的图，接下来我们只需要重复上面的步骤就行了。
> ```



### 精妙的存图方法(可以轻松用遍历边去访问邻接的点)

```c++
// 这种存两次的像有向边的方法! from 连接的是边, to连接的是点
void AddEdge(int x, int y, int W) {
	cnt++;
	edge[cnt].from = head[x];
	head[x] = cnt;		// 存着这个点连接的边的编号, 下一次另一条边(含有这个点的)进来可以连接上这条边
	edge[cnt].to = y;
	edge[cnt].w = W;
}

// 然后main函数里加边方法:
// 加边（无向图）
	for (int i = 1; i <= m; i++) {
		int x = read(), y = read(), w = read();
		R = max(R, w);//二分右端点要用的
		AddEdge(x, y, w);
		AddEdge(y, x, w);
	}


// 访问邻接点时!!!
// x是最开始的点, 这样遍历的i就都是连接着x的, edge[i].to 就是邻接的点了!!!
for (int i = head[x]; i != 0; i = edge[i].from) {

```

原来上面的精妙存图方式是: **链式前向星**

## 链式前向星

### 结构

```c++
struct Edge {
	int next;	// 下一条边的下标(默认为0)
	int to;		// 这条边的终点
	int w;		// 这条边的权值
};
```

### 增边

```c++
int cnt = 0;
void Add(int u, int v, int w) {		// 起点u, 终点v, 权值w 
	// 前两句是为了连接起整个图的
	edge[++cnt].next = head[u];
	head[u] = cnt;				   // 为下一次 next 连接做准备

	edge[cnt].w = w;
	edge[cnt].to = v;
}
```

### 遍历

```c++
// i 开始为第一条边，每次指向下一条 (其实是输入顺序的上一条) (以 0 为结束标志)
// 若下标从 0 开始，next 应初始化 -1 ! (不要这样做/xk)
for (int i = head[start]; i != 0; i = edge[i].next)
```

**一定要好好理解!!! `head[]` 沟通了 点(下标 `i`) 和 边(`head[i]`)**`head[i] 存的是连接 i 点 ( 而且 i 是起点的下标) 的 最后输入的 边, 然后找其他边可以通过 edge[i].next 去找前面输入的边`, 

`start`就是开始的点的下标, 点要从 `1` 开始存

## 动规提高

### 例题 1052 过河之路径压缩: 这题主要就是路径压缩, 还未懂...

目的是要找到两石同相隔较长时直接缩短的方法

假设每次走p或者p+1步.我们知道$\gcd(p,p+1)=1.$

由**扩展欧几里得**( [扩展欧几里德算法]是用来在已知a, b求解一组x，y，使它们满足贝祖等式： ax+by = gcd(a, b) =d（解一定存在，根据[数论]中的相关定理）)可知，对于二元一次方程组：

$px+(p+1)y=\gcd(p,p+1)​$是有整数解的，即可得：$px+(p+1)y=s​$是一定有整数解的.

设$px+(p+1)y=s$的解为：$x=x0+(p+1)t,y=y0-pt$。令$0<=x<=p$(通过增减$t个p+1$来实现)，$s>p*(p+1)-1$,

则有：

$y=\frac{s-px}{p+1}>=\frac{s-p^2}{p+1}>\frac{p*(p+1)-1-px}{p+1} >= 0​$

即表示，当 $s>=p*(p+1)$ 时，$px+(p+1)y=s$ 有两个非负整数解，每次走p步或者 $p+1$ 步，$p*(p+1)​$ 之后的地方均能够到达。

如果两个石子之间的距离大于 $p*(p+1)​$ ，那么就可以直接将他们之间的距离更改为 $p*(p+1)​$ 

**综上，得到压缩路径的方法：若两个石子之间的距离大于 $t*(t-1)$ ，则将他们的距离更改为 $t*(t-1)$ .**

因为 $t<=10​$ ，因此我们可以直接将大于10*9的距离直接化为90.

但是要注意，对于 $s=t$ 这种特殊情况，这种方法是不成立的, 因为在这种情况下，每次是不能够走p+1步的，因此需要另外特殊判断。

方程如下:

$f[i]=f[i-1]+(i \mod s ==0)$



### 区间dp

#### 1220关路灯

可以得到两种状态（沿着当前方向继续往下走，改变方向回去关灯）, **又因为如果想要关某一区间的灯的过程中耗能最小，所以可以转换成一个个区间来写：** 

> 去关某一区间的灯，那么整条街道上除了这一区间的灯会逐渐灭掉其他肯定会全亮; 那么我们把`f[i][j]`记为当从 `i 到 j` 的灯都熄灭后剩下的灯的总功率。

再进一步：`f[i][j][0]`表示关掉`i到j`的灯后，老张站在左端点，f[i][j][1]表示关掉后,老张站在右端点

（i为左端点，j为右端点）

### 数学类也可以有dp

![1550199115846](C:\Users\Kai\AppData\Roaming\Typora\typora-user-images\1550199115846.png)

`状态转移方程: dp[n][m] = dp[n-1][m] + dp[n][m-1] - dp[n-1][m-1] `,

`dp[n-1][m-1]`用来去重, 因为 `n - 1, m - 1` 这个点被加了两次

`换句话说，dp[n][m] = dp[n-1][m-1] + C(n,m-1)新增量 + C(n-1,m）新增量。`

### 难理解的动规

**题目描述**

小明的花店新开张，为了吸引顾客，他想在花店的门口摆上一排花，共*m*盆。通过调查顾客的喜好，小明列出了顾客最喜欢的*n*种花，从1到*n*标号。为了在门口展出更多种花，规定第*i*种花不能超过$a_i$盆，摆花时同一种花放在一起，且不同种类的花需按标号的从小到大的顺序依次摆列。

试编程计算，一共有多少种不同的摆花方案。

![1550238921496](C:\Users\Kai\AppData\Roaming\Typora\typora-user-images\1550238921496.png)



## 记忆化搜索[%%%](https://interestinglsy.blog.luogu.org/memdfs-and-dp)

#### 总结一下记忆化搜索是啥:

- 不依赖任何 **外部变量**

- **答案**以返回值的形式存在, 而不能以参数的形式存在(就是不能将 `dfs` 定义成 `dfs(pos, tleft, nowans)` , 这里面的 `nowans` 不符合要求).

- 对于**相同一组参数**, `dfs` 返回值总是相同的

> 记忆化搜索和动态规划**从根本上来讲就是一个东西**,(印象中)任何一个 `dp `方程都能转为记忆化搜索 ，反之亦然（为什么？见下文“体现在”的第四条）

体现在:

- 根据**记忆化搜索**的参数可以直接得到`dp`的状态，反之亦然

- 根据**记忆化搜索**的递归关系可以写出状态转移方程，这个方程可以直接写出循环式的`dp`，**只不过是反的**(想想为什么？)，反之亦然

- 大部分记忆化搜索时空复杂度与 **不加优化的** dp 完全相同

- ### 最重要的一点：二者思想类似！！ 核心思想均为：**利用对于相同参数答案相同的特性**，对于相同的参数（循环式的`dp`体现为数组下标），记录其答案，免去重复计算，从而起到优化时间复杂度的作用。这，便是二者的精髓。

建议好好想想第四条。记住，学一个算法，一定要理解他的精髓。

举个栗子:

dp[i][j][k] = dp[i+1][j+1][k-a[j]] + dp[i+1][j][k]*d**p*[*i*][*j*][*k*]=*d**p*[*i*+1][*j*+1][*k*−*a*[*j*]]+*d**p*[*i*+1][*j*][*k*]

转为

```cpp
int dfs( int i , int j , int k ){
    边界条件
    if( mem[i][j][k] != -1 ) return mem[i][j][k];
    return mem[i][j][k] = dfs(i+1,j+1,k-a[j]) + dfs(i+1,j,k);
}
int main(){
    memset(mem,-1,sizeof(mem));
    读入
    cout << dfs(1,0,0) << endl;
}
```

二者满足上面提到的所有关系

------------

记忆化搜索 = 搜索的形式 + 动态规划的思想

### 1005矩阵取数

思路: 按行进行**区间DP**，我们可以设区间`[L,R]`的最大值为$f[L][R]$,用一个数组$p[n]$来储存$2^n$的值,采用**记忆化搜索**的办法,

设**k=m-(R-L)**,可以得到状态转移方程:$f[L][R]=max(num[L] \times p[k]+dp(L+1,R),   dp(L,R-1)+num[R] \times p[k])$
即选掉开头的那个, 和选掉末位的那个, 注意**要有递推如何进行的思想!**

```c++
#define k (m-(R-L)) // k: 当前选取次数, m: 每行个数

// 本质就是一个dfs/递归搜索
int dp(int L, int R) {
	// 如果答案的结点被更新了说明已经有答案了, 剪枝
	if (f[L][R] != -1)
		return f[L][R];
	if (R - L >= 1) 
		f[L][R] = max(num[L] * p[k] + dp(L + 1, R), dp(L, R - 1) + num[R] * p[k]);
	// 只有一个的时候
	else
		f[L][R] = num[L] * p[k];
	return f[L][R];
}
```

## 树形DP

树形DP的这一特殊性： 没有环，dfs是不会重复，而且具有明显而又严格的层数关系。 利用这一特性，我们可以很清晰地根据题目写出一个在树（型结构）上的记忆化搜索的程序。而深搜的特点，就是“不撞南墙不回头”

### DAG上的动规( 算法入门经典 )

有向无环图上的动规是学习动规的基础, 

>  **嵌套矩形问题**: 两个整数 a, b 表示长和宽, (1, 5) 可以嵌套在(6, 2) 之内, 但不能嵌套在 (3, 4) 内, 选出尽可能多的矩形排成一行, 除了最后一个之外每一个矩形都可以嵌套在下一个矩形之内, 矩形编号的字典序应该尽量小
>
> 如果 x 可以嵌套在 y 里面, 就从 x 连一条有向边到 y. 这个有向图是无环的(自己思考) => 求这个DAG图的最长路径.

## 状压DP

一般基础的状压就是将一行的状态压成一个数，这个数的二进制形式反映了这一行的情况。所以位运算可以帮助我们解决很多问题, 很多棋盘问题都运用到了状压，同时，状压也很经常和ＢＦＳ及ＤＰ连用

![1550540870183](C:\Users\Kai\AppData\Roaming\Typora\typora-user-images\1550540870183.png)

**优先级问题: 一般位运算最好打括号**



**例子:**

设n = 9；
有二进制数 100011011（九位），每一位表示该农田是否被占用，1表示用了，0表示没用，这样一种状态就被我们表示出来了：见下表

| 列 数  | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    |
| ------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 二进制 | 1    | 0    | 0    | 0    | 1    | 1    | 0    | 1    |
| 是否用 | √    | ×    | ×    | ×    | √    | √    | ×    | √    |

所以我们最多只需要 2n+1−12n+1−1 的十进制数就好（左边那个数的二进制形式是n个1）

现在我们有了表示状态的方法，但心里也会有些不安:上面用十进制表示二进制的数，枚举了全部的状态，DP起来复杂度岂不是很大？没错，状压其实是一种**很暴力的算法**，因为他需要遍历每个状态，所以将会出现2^n的情况数量，不过这并不代表这种方法不适用：**一些题目可以依照题意，排除不合法的方案，使一行的总方案数大大减少从而减少枚举**

### 具体技巧:

```c++
if (state & (1 << j - 1) != 0) {
    // 判断第 j 位上是不是 1
    state ^= (1 << j - 1);		// 1 和 1 异或之后为 0, 就是把第 j 位上的翻转了
}

else if (state & (1 << j - 1) == 0) {
    state |= (1 << j - 1);		// 翻转
}

// 然后每个状态都是一个数表示
```



### 例题:

#### 洛谷1879玉米田

读入以后，我们用`F[i]`来表示第`i`行上的草地情况，这里F数组里的是二进制数。MAXSTATE是2n，也就是这道题的最大状态（n列都是1）。

然后我们在0~MAXSTATE-1这些状态里找到合法状态，也就是**不能两头牛的草地是相邻的**。**判断方法就是**把这个二进制数左移一位and，然后右移一位and。如果这个状态是合法的，那么都应该返回0。

且不会在贫瘠的草地上（和`(j & F[i]) == j`说明没有草地种在贫瘠的地方）

**技巧:**

```c++
// 判断 i (二进制01序列) 有没有两个 1 相邻
// 左移右移 与 上自己
((i & (i << 1)) == 0) && ((i & (i >> 1)) == 0);

// 判断此位置不能种, 比如 0100111, 有三个位置不能种
// 读入之后先转化成二进制:
F[i] = (F[i] << 1) + field[i][j];		// 之前读在 field[] 里面, 低位补零.
// 再:
(j & F[i]) == j						   // 成立就是可以
```



## 数论

### 组合数递推法打表

![1550198957673](C:\Users\Kai\AppData\Roaming\Typora\typora-user-images\1550198957673.png)

**打表打表打表记住哇, 顺便去复习快速幂!!!**

组合数递推法
针对大多数仅仅是利用组合数求解问题的题目运用递推法打表，不仅方便，而且可以稳稳地控制复杂度，对于需要多次引用组合数的题目效果极佳:

由 $ C^m_n = \frac{n!}{m!(n-m)!}$
推得：$ C^m_n=C^{m-1}_{n-1}+C^{m-1}_n​$

由这个递推公式就可以熟练的写出组合数代码，但要**注意初始化:**
$C^0_0=1$
$C^i_0=C^1_0=C^1_1=1$ ( $i$为自然数 )

同时，把表打出来后，我们会发现———这就是杨辉三角，这个三角可以解决很多问题，记住打印三角的方法也可以打出组合数

```c++
const int MAXN = 2000;
inline void Init() {
    // 初始化
    c[0][0] = 1;
    c[1][0] = 1;
    c[1][1] = 1;
    for (int i = 2; i < MAXN; ++i) {
        c[i][0] = 1;
        for (int k = 1; k <= i; ++k) {
            // 递归
            c[i][k] = c[i][k - 1] + c[i - 1][k - 1];
        }
    }
}
```



### 二项式定理

$( a x + b y ) ^ { k } = \sum _ { p = 0 } ^ { k } C _ { k } ^ { p } ( a x ) ^ { p } ( b y ) ^ { k - p } = \sum _ { p = 0 } ^ { k } \left( C _ { k } ^ { p } a ^ { p } b ^ { k - p } \right) x ^ { p } y ^ { k - p }$

注意 $a^p​$ 之类都去用快速幂

$C _ { n } ^ { m } = C _ { n - 1 } ^ { m } + C _ { n - 1 } ^ { m - 1 }$

组合数的公式 一定不要忘!!!



### 斐波那契之 $g c d ( F [ n ] , F [ m ] ) = F [ g c d ( n , m ) ]$ 推导

![1550539065473](C:\Users\Kai\AppData\Roaming\Typora\typora-user-images\1550539065473.png)

注意这里消去$F[n] \times F[m - n - 1]$ 

![1550539103586](C:\Users\Kai\AppData\Roaming\Typora\typora-user-images\1550539103586.png)

注意

>  上面互质引理证完之后, 消去$F[n + 1]$ 
>
> $\operatorname { gcd } ( F [ n ] , F [ m ] ) = g c d ( F [ n ] , F [ m \bmod n ] )$ **怎么推?** 是上一行中的$m-n$当作新数$m$，等同于继续重复$m-n$，等同于$m\%n$





## 前缀和与差分

### 一维前缀和

```c++
// 前缀和
a[0] = 0;
for(int i = 1; i <= n; ++i)
	a[i] += a[i-1];
```

**前缀和顾名思义就是前面 i 个数的总和**

#### 差分

**例题理解:** 给你一串长度为n的数列$a_1,a_2,a_3......a_n，$要求对$a[L]~a[R]$进行$m$次操作：

**操作一：**将a[L]~a[R]内的元素都加上P

**操作二：**将a[L]~a[R]内的元素都减去P

最后再给出一个询问求 a[L]~a[R] 内的元素之和？

差分方法: **新开一个数组b，储存每一次的修改操作，最后求前缀和的时候统计一下就能快速的得到正确答案了**，

```c++
#include<bits/stdc++.h>
using namespace std;
const int maxn = 1e5 + 9;
int a[maxn], b[maxn];
int main(){
	int i, j, k, n, m, p;
	cin >> n >> m;
	for (i = 1; i <= n; i++){
		cin >> a[i];
	}
    // m 次操作
	for (i = 1; i <= m; i++){
		int L, R, t;
		cin >> t >> L >> R >> p;
		if (t == 1) {
            b[L] += p; 
            b[R + 1] -= p;	// 注意这句话!!! b[L] 就是一个开始加的标志位( 结合下面add += b[i]理解 ) 在 R + 1 之后的位置, 要取消这个加的标志位, 所以要 b[R + 1] -= p;
		}
		else{
			b[L] -= p; b[R + 1] += p;
		}
	}
	int add = 0;
	for (i = 1; i <= n; i++){
		add += b[i];			// L ~ R +p 只有b[L] == p, b[R + 1] == -p, 注意因为add += b[L] 之后, 后面的都会有影响, 都会加上去 => 这一段前缀和都有 +p.
		a[i] += a[i - 1] + add;
	}
	int x, y;
	cin >> x >> y;
	cout << a[y] - a[x - 1] << endl;
}
```

### 二维前缀和

**例题:**  给定一个n\*m大小的矩阵a，有q次询问，每次询问给定x1,y1,x2,y2四个数，求以(x1,y1)为左上角坐标和(x2,y2)为右下角坐标的子矩阵的所有元素和。注意仍然包含左上角和右下角的元素。

**`a[i][j]` 表示的是以 `a[i][j]` 为最右下点的左上方矩阵的和**

```c
// 二维前缀和
for (int i = 1; i <= n; i++) {
	for (int j = 1; j <= m; j++)
		a[i][j] += a[i][j - 1] + a[i - 1][j] - a[i - 1][j - 1];		// a[i - 1][j - 1] 加了两遍
}
```

![1550201501527](C:\Users\Kai\AppData\Roaming\Typora\typora-user-images\1550201501527.png)

#### 差分:

```c
for (int i = 0; i<m; i++){	// m 是修改操作次数 
	int x1, y1, x2, y2, p;
	cin >> x1 >> y1 >> x2 >> y2 >> p;
	b[x1][y1] += p; b[x2 + 1][y2 + 1] += p;
	b[x2 + 1][y1] -= p; b[x1][y2 + 1] -= p;
}
```

## 贪心

**贪心时常很牛逼!**

**题目描述**

2020年，人类在火星上建立了一个庞大的基地群，总共有n个基地。起初为了节约材料，人类只修建了n-1条道路来连接这些基地，并且每两个基地都能够通过道路到达，所以所有的基地形成了一个巨大的树状结构。如果基地A到基地B至少要经过d条道路的话，我们称基地A到基地B的距离为d。
由于火星上非常干燥，经常引发火灾，人类决定在火星上修建若干个消防局。消防局只能修建在基地里，每个消防局有能力扑灭与它距离不超过2的基地的火灾。
你的任务是计算至少要修建多少个消防局才能够确保火星上所有的基地在发生火灾时，消防队有能力及时扑灭火灾。

**思路:**

**树形的**, 考虑当前深度最大的叶子结点，你肯定要有一个消防局去覆盖它，那么既然他是叶子结点，所以与他距离小于等于2的节点有这么几种：

1. 他的父亲 
2. 他的兄弟 
3. 他的爷爷

容易看出，在前两项能够覆盖到的节点，在爷爷那里设立一定也能覆盖到。所以每次贪心取出深度最大的节点，在他的爷爷那里放一个消防站

```c++
// 题解1
// 树还可以这样表示! 注意输入格式 和 deep[], index[] 的结合
#include<iostream>
#include<cstdio>
#include<algorithm>
#define N 2020
#define FOR(i,a,b) for(int i=a;i<=b;i++)
using namespace std;
int n, index[N], f[N], deep[N], dp[N], ans, grand, child, fathe;

// 又出现的这样的排序方式!!!
bool cmp(int x, int y) {
	return deep[x] > deep[y];
}

// dp[i] 是第 i 个结点离最近消防站的距离
int main() {
	scanf("%deep", &n); 
	index[1] = 1, dp[1] = dp[0] = N;
	FOR(i, 2, n) {
		scanf("%deep", &f[i]);
		// 计算深度
		deep[i] = deep[f[i]] + 1;
		index[i] = i;    // 存下标
		dp[i] = N;	 // 初始化
	}

	// index[i] 就是 deep[]深度数组的下标, 我们只需要下标 ( 就是点的坐标 )
	sort(index + 1, index + n + 1, cmp);

	// 有点像dp咯
	FOR(i, 1, n) {
		// 从深度最大的结点开始, 就是 index[] 的排序
		child = index[i], fathe = f[child], grand = f[f[child]];
		// 更新
		dp[child] = min(dp[child], min(dp[fathe] + 1, dp[grand] + 2));
		// 把爷爷结点设置为消防站
		if (dp[child] > 2) {
			dp[grand] = 0;
			++ans;
			// 更新
			dp[f[grand]] = min(dp[f[grand]], 1);
			dp[f[f[grand]]] = min(dp[f[f[grand]]], 2);
		}
	}
	
	printf("%deep", ans);

	return 0;
}
```



## AC自动机

~~挑战一下~~
https://www.cnblogs.com/cmmdc/p/7337611.html

`Aho-Corasick automation`是著名的**多模匹配算法**之一。一个常见的例子就是给出n个单词，再给出一段包含m个字符的文章，让你找出有多少个单词在文章里出现过。

**AC自动机和字典树的关系比较大，所以先来简单的了解下字典树Trie树**。

字典树又称单词查找树，Trie树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的**优点**是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。

简而言之：字典树就是像平时使用的字典一样的，我们把所有的单词编排入一个字典里面，**当我们查找单词的时候，**我们首先看单词首字母，进入首字母所再的树枝，然后看第二个字母，再进入相应的树枝，假如该单词再字典树中存在，那么我们只用花费单词长度的时间查询到这个单词。

**AC自动机关键点一：字典树的构建过程：**

字典树的构建过程是这样的，当要插入许多单词的时候，我们要从前往后遍历整个字符串，

1. 当我们发现当前要插入的字符其节点再先前已经建成，我们直接去考虑下一个字符即可

2. 当我们发现当前要插入的字符没有再其前一个字符所形成的树下没有自己的节点，我们就要创建一个新节点来表示这个字符，接下往下遍历其他的字符。然后重复上述操作。

注意开头字符都在 root 下一层

![1550224673853](C:\Users\Kai\AppData\Roaming\Typora\typora-user-images\1550224673853.png)

**AC自动机关键点二：找Fail指针**

在KMP算法中，当我们比较到一个字符发现失配的时候我们会通过next数组，找到下一个开始匹配的位置，然后进行字符串匹配，当然KMP算法试用于**单模式匹配**，所谓单模式匹配，就是给出一个模式串，给出一个文本串，然后看模式串在文本串中是否存在。

**在AC自动机中，我们也有类似next数组的东西就是fail指针**，当发现失配的字符失配的时候，跳转到fail指针指向的位置，然后再次进行匹配操作，**AC自动机之所以能实现多模式匹配，就归功于Fail指针的建立。**

当前节点 t 有 fail 指针，其 fail 指针所指向的节点**和 t 所代表的字符是相同的。**
因为t匹配成功后，我们需要去匹配`t->child`，发现失配，那么就从 `t->fail` 这个节点开始再次去进行匹配。

**Fail指针的求法：**
Fail指针用BFS来求得，对于直接与根节点相连的节点来说，如果这些节点失配，他们的Fail指针直接指向root即可，其他节点其Fail指针求法如下：

>- 假设当前节点为father，其孩子节点记为child。求child的Fail指针时，首先我们要找到其father的Fail指针所指向的节点,
>- 假如是 t 的话，我们就要看 t 的孩子中有没有和child节点所表示的字母相同的节点，
>- - 如果有的话，这个节点就是child的fail指针，
>  - - 如果发现没有，则需要找father->fail->fail这个节点，然后重复上面过程，如果一直找都找不到，则child的Fail指针就要指向root。

**实例 ( 有颜色的就是 fail 指针 ):**

![1550225206126](C:\Users\Kai\AppData\Roaming\Typora\typora-user-images\1550225206126.png)

如图所示，首先root最初会进队，然后root,出队，我们把root的孩子的失败指针都指向root。因此图中h,s的失败指针都指向root, 如红色线条所示，同时h,s进队。

接下来该h出队，我们就找h的孩子的fail指针，首先我们发现h这个节点其fail指针指向root,而root又没有字符为e的孩子，则e的fail指针是空的，如果为空，则也要指向root,如图中蓝色线所示。并且e进队，此时s要出队，我们再找s的孩子a,h的fail指针，
我们发现s的fail指针指向root,而root没有字符为a的孩子，故a的
fail指针指向root，a入队，然后找h的fail指针，同样的先看s的fail指针是root，发现root又字符为h的孩子，所以h的fail指针就指向了第二层的h节点。e，a , h 的fail指针的指向如图蓝色线所示。

此时队列中有e,a,h，e先出队，找e的孩子r的失败指针，我们先看e的失败指针，发现找到了root,root没有字符为r
的孩子，则r的失败指针指向了root,并且r进队，然后a出队，我们也是先看a的失败指针，发现是root,则y的fail指针就会指向root.并且y进队。然后h出队，考虑h的孩子e,则我们看h的失败指针，指向第二层的h节点，看这个节点发现有字符值为e的节点，最后一行的节点e的失败指针就指向第三层的e。最后找r的指针，同样看第二层的h节点，其孩子节点不含有字符r，则会继续往前找h的失败指针找到了根，根下面的孩子节点也不存在有字符r，则最后r就指向根节点，最后一行节点的fail指针如绿色虚线所示。



## Tarjan

https://www.cnblogs.com/shadowland/p/5872257.html
求解有向图强连通分量的算法，时间复杂度为O(E+V).

**定义:** 如果两个顶点可以相互通达，则称两个顶点强连通(strongly connected)。如果有向图G的每两个顶点都强连通，称G是一个强连通图。有向图的极大强连通子图，称为强连通分量(strongly connected components)。

![1550488475562](C:\Users\Kai\AppData\Roaming\Typora\typora-user-images\1550488475562.png)

**例如：**在上图中，{1 , 2 , 3 , 4 } , { 5 }　,  { 6 } 三个区域可以相互连通，称为这个图的强连通分量。

Tarjan算法是**基于对图深度优先搜索的算法**，**每个强连通分量为搜索树中的一棵子树**。
搜索时，把当前搜索树中未处理的节点加入一个堆栈，**回溯时**, 可以判断栈顶到栈中的节点是否为一个强连通分量。

再Tarjan算法中，有如下定义。

> `DFN[ i ]` : 在DFS中该节点被搜索的次序( 时间戳 )
>
> `LOW[ i ]` : 为`i`或`i`的子树**能够追溯到的最早的栈中节点的次序号**

**当`DFN[ i ] == LOW[ i ]`时，为`i`或`i`的子树可以构成一个强连通分量。**

**注意`LOW[ i ]`的作用: `拓展节点1 ，发现1在栈中, 更新LOW[ 4 ]，LOW[ 3 ] 的值为 1`.**

**上一句的具体解释: **

> **`low[x]=dfn[x]=++tim;`**
>
> **`low[x]=min(low[x],low[v]);`**
>
> `我截取了两句代码，第一句是对点x的low，dfn的初始化。在之后的操作中,low[x]始终取自己子树low[v]的较小值，那么什么情况会使得dfn[u]又“重新”和low[u]相等呢，就是在u的子树中有一条边（就是网站 https://blog.csdn.net/acmmmm/article/details/16361033中的后向边）直接指回了u。这样不就是形成了一个环了吗？`

**栈的表示:**

> 还有值得注意的，这个栈表示的究竟是什么？表示的是当前`dfs`搜索的一条链上的一个个点吧。

具体看网站: https://www.cnblogs.com/shadowland/p/5872257.html

其他也不错的网站: https://blog.csdn.net/acmmmm/article/details/16361033, 其中讲到: 

![1550491804879](C:\Users\Kai\AppData\Roaming\Typora\typora-user-images\1550491804879.png)

**用是不是在栈中判断是不是有环**

### 缩点

缩点，就是把一张有向有环图中的环缩成一个个点，形成一个有向无环图。



## Tarjan求割点

在**无向连通图**中，如果将其中**一个点以及所有连接该点的边**去掉，图就不再连通，那么这个点就叫做割点（cut vertex / articulation point）。

> 首先选定一个根节点，从该根节点开始遍历整个图（使用DFS）。
>
> 对于根节点，判断是不是割点很简单——计算其子树数量，如果有2棵即以上的子树，就是割点。因为如果去掉这个点，这两棵子树就不能互相到达。

> `对于非根节点，判断是不是割点就有些麻烦了。我们维护两个数组 dfn[] 和 low[]，dfn[u]表示顶点u第几个被（首次）访问，low[u]表示顶点u及其子树中的点，通过非父子边（回边），能够回溯到的最早的点（dfn最小）的dfn值（但不能通过连接u与其父节点的边）。` **`对于边(u, v)，如果low[v] >= dfn[u]，此时u就是割点。`**

**`dfn[], low[] 具体计算方法看上面的Tarjan算法描述, 关键就是: 如果low[v] >= dfn[u]，此时u就是割点。`**



## 二分

### 例题: 洛谷1642通往奥格瑞玛的道路

> 输出格式：
> 仅一个整数，表示歪嘴哦交费最多的一次的最小值。
>
> // 题目："他所经过的所有城市中最多的一次收取的费用的最小值是多少？"
> // **这句话的意思实际上是指：**
> //         对于一条路径 a ， 定义函数f(a)。
> //         对于路径上的所有点权构成的集合s， 满足f(a)=max(s)
> //         而对于一张图，从起点到终点存在多条路径a1,a2,a3...
> //         对于所有可能的路径a1,a2,a3...，均存在对应的f(a1),f(a2),f(a3)...
> //         求f(a1),f(a2),f(a3)...中的最小值
>
> **基本思路:** 
> //基本的思想就是二分，**二分什么呢？**
> //         被二分的一定是一个包含解的集合 
> //         首先，你的f(a)是等于max(s)的，f(a)一定是一个点权，即我们所求的解为一个点权, 就是这个结点过路费
> //         而你走过的每一个路径中的最小点权f(a)一定在一个区间内: 即整张图的最低点权与最高点权之间
> //         通过对整张图的点权进行排序，然后做二分，在整张图的点权集合中找出一个点权，这个点权是min(  f(a1)  f(a2)  f(a3) ... ) 就是本题答案了
> /**/我们已经找到了解的集合(解的范围)：点权集合。**
> //二分点权集合，每一次都会得到一手点权，这个点权将是路径上所有点点权的天花板
> //在整张图上寻找路径，**但是因为我们得到了一个天花板，所以点权大于这个天花板的点就不能选**  // 注意这里!!!
> //寻找路径也应该是最短路，因为你会扣血，所以**需要找到扣血最少的**路径
> //要是找到的这个路径上的扣血总和依然致死，那么我们找到的点权就是无效的，继续向上二分，扩大点权范围 
> //要是不致死，那么分出的点权就是有效的，继续向下二分，缩小点权范围 



二分是一定要用的 **这种问法**基本十个有九个是要用二分, 那么我们要二分什么呢 血量还是金钱呢, 因为要求的是收费所以就二分金钱, 
二分的条件就是 以当前值为最大值 判断 **( 转变成判定问题 )** 是否有一条路可以使得

**每条边的收费都小于等于此值 并且 走到终点之后血量不会被扣光（边界应该是血量<=0就算死了）**



## Dijkstra + 堆优化

```c++
struct cmp {
	bool operator()(int a, int b) {
		return dis[a] > dis[b];			// 这里配的是 dis[] !!!
	}
};
// 注意这个cmp的搭配
priority_queue<int, vector<int>, cmp> Q;

void dijkstra(int s) {
	Q.push(s);
	//vis[s]=1;
	dis[s] = 0;
	while (!Q.empty()) {
		int u = Q.top();
		Q.pop();
		if (vis[u])
			continue;
		vis[u] = 1;
		for (int i = head[u]; i; i = next[i]) {
			int v = to[i];
			if (!vis[v] && dis[v] > dis[u] + cos[i]) {
				dis[v] = dis[u] + cos[i];
				Q.push(v);
			}
		}
	}
}

// 可以看一下 洛谷最短路1346电车有带路口的转化.cpp 里面是无堆优化的
```



## 网络流

### 网络流的基本概念[¶](https://oi-wiki.org/graph/flow/#_1)

>**流量：**对于网络中的每条边的流量需要满足以下三条性质：
>1. 容量限制：对于每条边，流经该边的流量不得超过该边的容量
>2. 斜对称性：每条边的流量与其相反边的流量之和为 0
>3. 流量守恒：从源点流出的流量等于汇点流入的流量。

#### 最大流[¶](https://oi-wiki.org/graph/flow/#_3)

我们有一张图，要求从**源点流向汇点的最大流量**（可以有很多条路到达汇点），就是我们的最大流问题。

#### 最小费用最大流[¶](https://oi-wiki.org/graph/flow/#_4)

最小费用最大流问题是这样的：**每条边都有一个费用，代表单位流量流过这条边的开销**。我们要在求出最大流**的同时**，要求花费的费用最小。

#### 最小割[¶](https://oi-wiki.org/graph/flow/#_5)

割其实就是删边的意思，当然最小割就是割掉 $X$ 条边来让 $S$ 跟 $T$ 不互通。我们要求 $X​$ 条边加起来的流量综合最小。这就是最小割问题。

### 拆点[%%%](https://oi-wiki.org/graph/flow/node/)

例题: [luogu  P4568  飞行路线](https://www.luogu.org/problemnew/show/P4568)[¶](https://oi-wiki.org/graph/flow/node/#luogu-p456891jloi201193)

**分层图最短路**:

看看题目, 有免费( 权值为零的路线 )放在哪里好像都可以, 这种用分层, 有向的, 只能下去一次, 这样的话**有几层就保证了乘坐免费的次数是几层**

![1550714466597](C:\Users\Kai\AppData\Roaming\Typora\typora-user-images\1550714466597.png)

**注意建图, 实际上就是**: 如上图, 0 -> 2, 所以要**连接下面的复制的** 2 (就是 7), 所以0 -> 7 有一条权值为零的路, 注意每一层都要连, 上图是只有一次免费乘机的情况. 0 -> 7 就表示0 -> 2 这一次使用了免费乘机.

预防特殊情况:

​	// 预防奇葩数据, 就是不需要 k 次免费机会就到了终点 => 到某一层的终点即可 => **各层终点之间连接一条权值 0 的边**



## 看到了大佬的模板,,,

```c++
#define debug(...) fprintf(stderr,__VA_ARGS__)
#define DEBUG printf("Passing [%s] in LINE %lld\n",__FUNCTION__,__LINE__)
#define Debug debug("Passing [%s] in LINE %lld\n",__FUNCTION__,__LINE__)
#define all(x) x.begin(),x.end()
using namespace std;
const double eps = 1e-8;
const double pi = acos(-1.0);
typedef long long ll;
typedef pair<ll, ll> pii;
template<class T>ll chkmin(T &a, T b){ return a>b ? a = b, 1 : 0; }
template<class T>ll chkmax(T &a, T b){ return a<b ? a = b, 1 : 0; }
template<class T>T sqr(T a){ return a*a; }
template<class T>T mmin(T a, T b){ return a<b ? a : b; }
template<class T>T mmax(T a, T b){ return a>b ? a : b; }
template<class T>T aabs(T a){ return a<0 ? -a : a; }
#define min mmin
#define max mmax
#define abs aabs
```

## 对拍 && 调试

生成极端数据: 图的题生成树, 边界数据, 取到边界MAX.

### generator.cpp

```c++
#include <stdlib.h>
#include <iostream>
#include <time.h> 
using namespace std;
int main() {
	srand( (unsigned)time( NULL ) );
	unsigned int a, b;
	a = (rand() << 16) + rand();
	b = (rand() << 16) + rand();
	a %= 100000;
	b %= 100000;
	cout << a << endl << b; 
	return 0;
}
```

### duipai.bat

```tcl
:loop
generator.exe > data.txt   
gaojing.exe < data.txt > std.txt  
putong.exe < data.txt > ans.txt 
fc /A std.txt ans.txt
if not errorlevel 1 goto loop
pause
:end

# fc /A 就是比较这两个文件
# 如果没有报错, 就goto loop, 返回回去继续跑
```

### 对拍实例

[%%%](C:\Users\Kai\Documents\Visual Studio 2013\Projects\work\ZhangYikai\对拍实例)



## 错位输出

```c++
//这个例子将说明，关闭与stdio的同步后，混用两种IO的后果
//建议单步运行来观察效果
#include <iostream>
#include <cstdio>
using namespace std;
int main()
{
 ios::sync_with_stdio(false);
 //关闭IO后，cin/cout将使用独立缓冲区，而不是将输出同步至scanf/printf的缓冲区，从而减少IO耗时
 cout<<"a\n";
 //cout下，使用'\n'换行时，内容会被缓冲而不会被立刻输出，应该使用endl来换行并立刻刷新缓冲区
 printf("b\n");
 //printf的'\n'会刷新printf的缓冲区，导致输出错位
 cout<<"c\n";
 return 0;//程序结束时，cout的缓冲区才会被输出
}
```

