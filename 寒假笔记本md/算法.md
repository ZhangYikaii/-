# 算法`多刷题`

[TOC]

`tutorial` 里面有答案, 但是一定要自己想明白了, 再写到自己本子上, **不可以晚交作业!!!**

执行无穷多步 => 用归纳法证明.

带概率的加权的期望, **把蛮力想清楚**



### 未处理的题目

#### 残缺棋盘问题（DefectiveChessboard）

#### 手打快排, 归并等nlogn排序

#### Top k   O(n)    BFPTR 算法

#### 旋转数组 II   带有相同数字的

#### n 皇后[*](https://www.jiuzhang.com/solution/n-queens/#tag-highlight-lang-cpp)

#### 数学-到达一个数字:

```c++
	// 好好理解一下发生了什么
	int reachNumber(int target) {
        target = abs(target);
        long long n = ceil((-1.0 + sqrt(1+8.0*target)) / 2);
        long long sum = n * (n+1) / 2;
        if (sum == target) {
            return n;
        }
        long long res = sum - target;
        if ((res & 1) == 0) { 
            return n;
        } else {
            return n+((n&1) ? 2 : 1);
        }
    }
```



#### 玩游戏 ( 在下面 )

```c++
// https://blog.csdn.net/yaoct/article/details/85263568
long long MyMax(long long a, long long b) {
	return a > b ? a : b;
}

long long playGames(vector<int> &A) {
	long long max = 0;
	for (auto a : A){
		max = MyMax(a, max);
	}
	long long l = 0, r = max * 2;
	while (l<r){//cnt表式某一人完成时的游戏次数
		long long m = (l + r) / 2;
		long long cnt = 0;
		for (auto a : A) {
			cnt += MyMax(m - a, 0);
		}
		if (m>cnt){
			l = m + 1;
		}
		else{
			r = m;
		}
	}
	return MyMax(l, max);
}
```







### 需要看题解看一下优秀代码的题目

#### 三数之和



#### 连续无重复子串

```c++

int lengthOfLongestSubstring(string &s) {
	// write your code here
	int n = s.size();
	if (n <= 1)
		return n;

	// 注意啊 pre 一定是上一个相同的元素的后面一个!!! 想清楚哇
	int curMax = 0, pre = 1;
	map<char, int> m;
	for (int i = 0; i < n; ++i) {
		if (m[s[i]] == 0) {
			m[s[i]] = i + 1;
		}
		else if (m[s[i]] != 0) {
			curMax = max(curMax, i + 1 - pre);
			pre = max(pre, m[s[i]] + 1);			// 太 tm 多陷阱了, 程序lubang性很差啊啊啊
			m[s[i]] = i + 1;
		}
	}


	return max(curMax, n - pre + 1);
}
```





#### // 备忘

1. 纯暴力的先写, 有一个打底
2. 记得开long long



## Asymptotic Behavior

渐进的增长.. 今天学大O, 也就是有了对算法的分档, 不断改进算法一直上升到最好的档.

### Algorithm analysis

- simplification is important.
- large input size only

算法课关注的是 量级的关系, $n^2 + n$ 这里的 $+n$ 就比较没有影响了.

## 大$O$分析

大 $O$ 就是一个等价类, $O(n^2) 和 O(n^2 + n)$ 是在一个等价类里面.

记清大$O$ 的定义, **数学定义**, 注意这三个的量级的感觉. 问题规模一上去, 差别就太太太大了.

Basic idea $f(n) \in O(g(n))$,  $f(n) <= cg(n)$ 就是要满足的条件, $f(n)$ 是 the set of.....

**注意要用$\epsilon - N$语言, 看PPT**, 存在$N_0$ ...

一群函数, 他们的渐进增长率满足某些特征

渐进增长率差别非常大, 大到会用不同的档.

**$log n \in O(n^a)$ for any $a > 0​$ ... 各层级的分析, 看PPT...**

**分析 $n!$, 用` Stirling's formula` **

### 大$\Omega$ 分析

就是$f(n) >= cg(n)​$

### $\theta$ 甩不开

$0 <= c_1 * g(n) <= f(n) <= c_2 * g(n)...........n >= n_0$

### 小$o$ 

就是$f(n) < cg(n)​$ , any $c\in R​$, 注意这里因为$c​$是取定的, 取定$c​$, 存在$N_0, n > N_0 时​$ 

### 小$\Omega$ 

$f(n) > c g(n)$  any $c\in R$



## Brute Force Enumeration

从简单的暴力开始.

### Swapping array elements

给一个数组: 1, 2, 3, 4 | 5, 6, 7, 变成 => 5, 6, 7 | 1, 2, 3, 4

最后 从空间 $O(n) -> O(1)$ 时间  $O(n) -> O(n)$, 这个应该是 系数可能有变大. 

### 最大连续子段和

想清楚几种蛮力算法, 			lg1115

### Job Scheduling

递归, 类似`dfs`把全部序列列出来?

**蛮力 + 递归: 赖子递归:** 取不取A, 各自算, 然后比结果. 不管取A 还是不取A, 都下降了一个规模

### Matrix Multiplication

矩阵相乘的顺序影响代价, 矩阵结合律.

第一个蛮力, 第二个蛮力代价还很差但是为后续的dp改进做了充足准备

## 递归

bitcounting: 递归求比特数, 去掉一个比特 => 除二...

先用方程描述问题.

### 分治

#### max sum subsequence

一定要分治: **怎么分:** 经验主义; **均匀分**

分两半之后, 可能情况列出来: 1. 在左边, 2. 在右边. 3. 中间连起来

**代价! 纯数学的方程一定要敏感一点:**

**`T(n) = 2 T( n / 2 ) + n`**    后面的 n 就是另外搞一个算法, 处理中间连起来 的最大连续子串和

分治: 难分易合, 易分难合

### 解递归方程

用 bitcounting 为例子: 笨展开, 核心原理就是把展开的东西整合在一起( 用数学基础 )

![1551840157118](C:\Users\Kai\AppData\Roaming\Typora\typora-user-images\1551840157118.png)

$T(n)=T\left(\left\lfloor\frac{n}{2}\right\rfloor\right)+1​$

注意要取整, 算法的规模是自然数

最后的算法复杂度如果是 smooth function => $f(2 n) \in \Theta(f(n))$ 就可以不管奇数偶数.

### Guess and Prove(`归纳法`)

T(n) <= cn, 代入递归式之后, 如果推出 T(n) <= ( c + 1 ) n 还是不对的. 形式要规整...

注意$\left(\left\lfloor\frac{n}{2}\right\rfloor\right)$ 化出来是 (n - 1) / 2 还是 n / 2 要弄清楚

最后证出来 那个 c 是存在一个

### 递归树

$T(n)=3 T(n / 4)+\Theta\left(n^{2}\right)$ 这里表示分三份, 每份 n / 4.

统计的是 non-recursive cost

规律找好, 代价算出来, 每一层算出来, 找规律.

在大$O$ 意义下, 等比级数, 递增 => 最后一项, 递减 => 第一项.



## 节点总数 = 总度数 + 1（整棵树的根节点）

设度数为2的节点数为X2，度数为1的节点数为X1，度数为0的节点数为X0。那么久可以得出如下关系式：

    		X2+X1+X0=2X2+X1+1;
    推出     X2=X0-1;

**也就是我们结论：度数为2的节点个数等于叶节点数减1啦；**

### 另外，顺便记录下另外2个结论：

1. #### 满二叉树定理：非空满二叉树的叶节点数等于其分支节点数加1。

如果在已知前面论证的结论下来考虑这个定理：由于满二叉树所有分支节点都是度数为2的节点，那么结论自然成立。

如果并不知道上面已经论证的结论也没关系。考虑一棵只有3个节点的满二叉树(1个根节点和两个叶子节点)：此结论满足。从这开始思考。每产生1个分支节点(牢记度数为2)。便会多出1个叶子节点。为什么呢？因为要产生一个分支节点，那么这个新的分支节点必然是原来的叶子节点。而新的分支节点又有2个新的叶子节点。因此叶子节点的总数先是减少1，然后加2。相互抵消自然就是加1了。扩展开来思考，在原来结论的基础上，由于分支节点和叶子节点是等量增长。那么结论自然也还是成立了。

2. #### 一棵非空二叉树空子树的数目等于其节点数目加1

考虑只有1个根节点的二叉树：它有2个空子树，1个节点。因此结论成立。从这里开始考虑。每产生1个节点。空子树便会先减少1，然后增加2。就和上面结论中每多出1个分支节点，叶子节点的变化一样。因此在原来结论的基础上，由于空子树和节点等量增长。所以结论成立。

## 排序

=> **Eliminating Inversion**

算法好坏就是 看看一次比较, 消除了多少个逆序对, 排序的好坏 => 消除逆序对的快慢

引理: 相邻的元素交换最多消除一个逆序对.

### 插入排序

restrictive 的假设

shift vacancy 不断挪动空位, 就是待排序的那个元素.

// 尾递归, 编译器优化成循环.

关键是算法复杂度之类的分析.

#### 平均情况:

插入在每一个位置可能性一样.  注意最后一次比较的结果 : **比最前面的时候不管比它大还是小**都是比较一次.

$\frac{1}{i+1} \sum_{j=1}^{i} j+\frac{1}{i+1}(i)$



### 快速排序

分析是重点:

Worst Case: a Paradox

让划分极度不均匀. 就是:   $\sum_{k=2}^{n}(k-1)=\frac{n(n-1)}{2} \in \mathrm{O}\left(n^{2}\right)$

#### 平均情况:

注意教师手册里面的 102 页.

Assumption: all permutation of the keys are equally likely

不失一般性, 假设 

![1552447933815](C:\Users\Kai\AppData\Roaming\Typora\typora-user-images\1552447933815.png)

所有可能输入**等概率出现**

##### 递归表达:

$A(n)=(n-1)+\sum_{j=0}^{n-1} \frac{1}{n}[A(i)+A(n-1-i)] \quad$ for $n \geq 2$

再递归下去, $A(i)$ 里面的还是等概率出现, 因为一次比较之后, 只是前半段比 pivot 小, 只是搬到前面了, 还是乱序, 所以还是等概率出现

后面的就是直接分两半:
$$
A(n)=(n-1)+\frac{2}{n} \sum_{i=1}^{n-1} A(i) \quad \text { for } n \geq 1
$$
注意精华:

这个partition的过程, 一定是有一个类似快排的 pivot 的东西, 问题可以不断的划分下去.

##### 例题: Bolts and nuts

有一堆螺钉和螺母, 散乱了要找到他们的匹配, 找一个pivot 螺钉, 螺母分成前一堆, 后一堆, 找到匹配的那个螺母作为pivot, 再把螺钉分成两个部分, 然后分好的这两个部分, 前部分螺母和前部分螺钉进行递归.



## 数学归纳法

注意 2 ~ n 上每一个数都要成立, 链条才跑得起来.

要和自然数对起来, 找到不变式, 插入排序不变式就是 前面的有序部分一定是有序的. 就是在有序部分归纳

自然数集 可数 是可以和 有理数集 的 可数对应起来的.

用归纳法观点理解算法的正确与否.



## 堆

用数组存, 一个是访问父亲孩子还可以方便

### Heap Question: Where is the $k^{th}$ element in the heap

#### **K - top question ?**

顶部有一个 size( k ) 的函数, 上面这个规模包含了 top - k, 下面的一定就不包含了...



### Heap Question: Sum of heights

#### when the sum reaches n - 1?



## 分治典例

分治考虑的是分治之后, 两边已经得出了一点结论, 然后再合并, 所以合并是有一些基础的.

### 逆序对

的, 关键在: 分了之后就是怎么样在 O(n) 时间内找到跨越分界的逆序对

插入一些代码, 这些代码可以做一些中间的事情. 归并一定要重视递归的概念, 不要以为它是无序的, 后面就会是有序的.

当前比它大的, 后面的都会比它更大.

### 平面最大点对

一定要找一点条件, 筛出 O(n), 

图的题目一定要有划区域的思想, 划区域之后有一块区域, 点落在这里面 是 具有某些性质的.



## Finding max and min

两两配对比一次分成胜者组, 败者组, 再分别在两组里面跑一遍找到max 和 min.

但是为什么这里是分一次胜者组和败者组呢, Adversary Argument 以及算法分析告诉我们分一次是最优的.



## Matrix Search


这个问题有一个十分美好的前提，那就是我们所给的n×n矩阵是行列皆有序的，在这样的条件下，我们要寻找某个元素x在不在矩阵中，通过对手论证，我们可以做到线性时间O(n)。

 

首先是一个并不高效的方法，对每一行采用二分搜索，最多搜索n行，所以复杂度为O(nlog⁡n)

 

这里有一个超级机智的算法，`<Step-wise线性搜索>`从右上角开始，每次将搜索值x与右上角的值比较，如果大于右上角的值，则直接去除1行，否则，则去掉1列。如下所示，展示了在矩阵中查找x=28的过程

 ![1553271228732](C:\Users\Kai\AppData\Roaming\Typora\typora-user-images\1553271228732.png)

在对手论证中，我们只需要尽可能的构造一个数去查找，但是总是不满足条件，比如找不到的情况，就能达到最坏情况，而最短时间就是采用这种`<Step-wise>`方法了。这种查找方式最多也就是遍历完两遍对角线，总共的探查次数最多为n+n−1=2n−1，所以复杂度为O(n)。



## 25 Horses select 1st,2nd,3rd

 

问题描述：有25匹赛马，一片场地只有5条赛道，现在要求你用尽可能少的比赛场次来选出最快的前三名。

首先，至少每一匹马都有机会去跑一遍，所以至少要先比赛5场，得出总共25匹马的5个小组排名。接着，就是把每一组的冠军拿出来遛遛，第6场过后，我们就能选出冠军了，同时，我们也知道这第六场中的最后两名一定不可能是前三名了，因为他们至少都要输给已知的3匹马。顺带着，这两匹不可能的赛马所在小组里的马厩都不可能了，想想小组第一都败了。（咦，当年翁学姐小组第一但是没出线就是这么一回事儿啊！！！）那么问题来了，下面只用一场比赛能够搞定么？答案是：可以！！

我们先给出竞赛的情况，

![1553271528324](C:\Users\Kai\AppData\Roaming\Typora\typora-user-images\1553271528324.png)

每一行上，从快到慢排序，不失一般性，小组第一的就是X1, X=A,B,C,D,EX1, X=A,B,C,D,E，我们假设第六场比赛$A1>B1>C1>D1>E1$，>表示快的比较。那么A1一定是冠军！下面可能是第二、第三的只可能是$A2,A3,B1,B2,C1$这5个。为什么不可能是C2呢？因为C2C2至少输给了C1C1，而C1C1又至少输给了A1A1和B1B1，那么C2C2的最好成绩也不过是第四，其他的情况也是类似的分析。
所以在这第七场，遛一遛$A2,A3,B1,B2,C1​$, 就有第二、第三名产生了。



## 平摊分析

### TABLE-INSERT



小 $\theta$ 等价定义, 就是相比 大 $\Theta$ 拿掉了系数.

三重求和, 每一步的约束都要带到下一层.



## 期中复习!!!!!!!!!!!!!

> 需要看的
>
> 中序非递归; 前驱后继是什么遍历下的;\log (n !)

$$
\log (n !)
$$

$$
n ! \sim \sqrt{2 \pi n}\left(\frac{n}{e}\right)^{n}
$$

之类的怎么等价注意背一下.



循环不变式就是 一直等于的那个东西用公式一样写出来.

注意 O 之类的标准定义 背一下,  用 { } .        ` { f(n) | ... } ​` , 注意小o 时 任意 c > 0, 后面是严格小于.

递归树的每一层背下来.

### 考试注意:

数学归纳法证明, 就是证明循环不变式, 第一行先写:

Prove bt mathematical induction on the number k of loops





## 图



BFS为什么如此重要, prim 和 dijk 其实是一种算法, 从bfs角度去看.

图算法, 图问题, 优化问题, 优化方法.

对称有向图 => 无向图.



注意连通块 (等价类) 的概念, 开始点 ID 记为这个连通片的 ID, 如此往复.

想算法比较难, 如果是线性时间, 直接就是 O(m + n)

灰色主要是为了标记遍历进行到上面部分.



图遍历, 不断发现新结点, dfs深度优先遍历树, tree的每条边就是 TREE EDGE

Tree 的数学定义, 无向连通无环图.

发现新结点的过程有没可能有环.



## 割点 & 桥

如果存在至少一个孩子顶点 V 满足low[v] >= dnf[u]，就说明顶点V访问顶点U的祖先顶点，必须通过顶点U，而不存在顶点V到顶点U祖先顶点的其它路径，所以顶点U就是一个割点。对于没有孩子顶点的顶点，显然不会是割点。

来自<https://www.cnblogs.com/nullzx/archive/2017/12/04/7968110.html> 图很不错.

<https://www.cnblogs.com/collectionne/p/6847240.html> 代码分析很不错, 拆开了, 理解Tarjan求割点很不错



这句话好好理解:

```c++
low[i] = min(low[i], dfn[k]); // dfn[k] 可能不等于 low[k]，所以不能用 low[k] 代替 dfn[k], 否则会上翻过头了。
```



洛谷: 

<https://www.luogu.org/problemnew/solution/P3388>

> 首先tarjan求割点的重点就是dfn和low数组的理解。
>
> dfn[i]就是时间戳,即在什么时刻搜索到了点i,
>
> low[i]则是i点能回溯到的dfn最小的祖先,
>
> 搜索的时候判断一下当对于点x存在儿子节点y, 使得dfn[x]<=low[y]则x一定是割点。
>
> 因为只要x的子节点不能回溯到x的上面，就是没有返祖边超过x点，那么割掉x就能造成不连通了
>
> 好啦,基本算法介绍完,就要讲几个问题了.
>
> 首先，为什么此处
>
> ### low[a]=min(low[a],dfn[p]);
>
> 不能写作
>
> ### low[a]=min(low[a],low[p]);
>
> 在我的理解，由于此处是一张无向图，我们有双向建了边，导致节点可以回溯到它的父节点；
>
> 而如果从它的父节点或其父节点的另一棵子树上有向上很多的返祖边，
>
> 这时把子节点的low值赋为父节点的low，就可能导致其low==其父节点low<其父节点dfn，
>
> 从而使本该是割点的点被忽视了，答案就少了，所以就wa了。
>
> 另外本题还有几个注意点：
>
> 1. 给的图不一定是连通图，即求每个联通块的割顶
> 2. 输出格式别看错了2333
> 3. 链式前向星开边要2倍
>



# Tutorial

## BFS

图的遍历为什么一定会终止, 白 -> 灰 -> 黑的概念....  往前走 不可回退, **所以图遍历可以终止**

要有队列的感觉. 队列理解成一个调度器(贪心概念)

fresh -> fringe -> finished.

**复杂度视角**

n $\times$ 一个东西其实就是要遍历到所有点的感觉.

Priority Queue 用数组实现: 点: n 时间, 边 1 时间, Heap 实现: 点: logn, 边 logn.



Prim 算法 是 **用点建堆**, $logn$, 某一条边确定它的权值, 其实就是书本上连着 Fringe 的边的权值 决定这个点的权值是多少

所以要不断更新这个点的权值, 其实就是更新链接着Fringe的边的权值.



## MCE(老师自己取) 的一个框架

书P135.



## Dijk

如果出现负权, 比如$-x$ 那就把全部边都加上一个 $x$



## 在DAG上求SSSP

