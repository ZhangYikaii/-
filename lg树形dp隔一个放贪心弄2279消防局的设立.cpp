#include<iostream>
#include<cstdio>
#include<algorithm>
#define N 2020
#define FOR(i,a,b) for(int i=a;i<=b;i++)
using namespace std;
int n, b[N], f[N], d[N], itoXiaoMin[N], ans, grand, v, father;
bool cmp(int x, int y){ 
	return d[x]>d[y]; 
}

/*
问题在于怎样才能判断这个点覆盖到了没有。对于儿子或孙子覆盖他，可以在在儿子处设站时就标记它；而对于父亲和祖父覆盖他，可以用儿子对父亲的映射f来解决；问题在于兄弟。其实itoXiaoMin数组维护“离i最近的消防站到i的距离”，当itoXiaoMin[父亲]==1时，就能确定它是否被覆盖。
*/

/*
看大家写的DP好强...我这里就提供一种比较简洁的贪心吧。
贪心! 找到最低的没有被覆盖的点, 并在它的祖父处设置一个消防站
其实贪心思想楼上都已经说的很清楚了，就是找最低没被覆盖到的点，并在它的祖父处设一个消防站。考虑到这个点的所有子孙后代都已经被覆盖了，因此这时覆盖祖父能盖到更多额外的点，并保证结果不会更差。

很多思路是用dfs或堆求取最低节点，实际上没必要，只要预处理出深度（边输入边处理）并排序，碰到已覆盖就跳过，未覆盖就在祖父处设消防站，ans++。

问题在于怎样才能判断这个点覆盖到了没有。

对于儿子或孙子覆盖他，可以在在儿子处设站时就标记它；

而对于父亲和祖父覆盖他，可以用儿子对父亲的映射f来解决；

itoXiaoMin 数组维护离 i 最近的消防站到 i 的距离
兄弟的父亲 == 1 就可以推出这个兄弟有被覆盖到.
问题在于兄弟。其实，可以用itoXiaoMin数组维护“离i最近的消防站到i的距离”，当itoXiaoMin[父亲]==1时，就能确定它是否被覆盖。
*/


// 这种方法就是用于从下往上搜, 比较好的点在 itoXiaoMin[] 有点像动规那样更新信息.
int main() {
	// 据说是一个普适的方法
	scanf("%d", &n); b[1] = 1, itoXiaoMin[1] = itoXiaoMin[0] = N;
	FOR(i, 2, n) {
		// 这里f[] 直接输入就是了, 是因为此题特殊的输入.
		scanf("%d", &f[i]);
		d[i] = d[f[i]] + 1;				// 这个就是深度的数组.
		b[i] = i;
		itoXiaoMin[i] = N;
	}
	sort(b + 1, b + n + 1, cmp);
	// b[] 是 d[] 大小的下标排序
	FOR(i, 1, n){
		// v 是b[]按顺序排的下标
		// father 是当前v的父亲, grand 是祖父
		v = b[i], father = f[v], grand = f[f[v]];
		// 更新当前节点到消防站的最小值.
		// 这里更新就包含了兄弟结点有设置的情况.
		itoXiaoMin[v] = min(itoXiaoMin[v], min(itoXiaoMin[father] + 1, itoXiaoMin[grand] + 2));
		// 要在这个位置的祖父那里设立消防站.
		if (itoXiaoMin[v]>2){
			itoXiaoMin[grand] = 0, ans++;
			// 注意设立完了不要忘了更新.
			itoXiaoMin[f[grand]] = min(itoXiaoMin[f[grand]], 1);
			itoXiaoMin[f[f[grand]]] = min(itoXiaoMin[f[f[grand]]], 2);
		}
	}printf("%d", ans);
}

/*

题目描述
2020年，人类在火星上建立了一个庞大的基地群，总共有n个基地。起初为了节约材料，人类只修建了n-1条道路来连接这些基地，并且每两个基地都能够通过道路到达，所以所有的基地形成了一个巨大的树状结构。如果基地A到基地B至少要经过d条道路的话，我们称基地A到基地B的距离为d。

由于火星上非常干燥，经常引发火灾，人类决定在火星上修建若干个消防局。消防局只能修建在基地里，每个消防局有能力扑灭与它距离不超过2的基地的火灾。

你的任务是计算至少要修建多少个消防局才能够确保火星上所有的基地在发生火灾时，消防队有能力及时扑灭火灾。

输入输出格式
输入格式：
输入文件名为input.txt。

输入文件的第一行为n （n<=1000），表示火星上基地的数目。接下来的n-1行每行有一个正整数，其中文件第i行的正整数为a[i]，表示从编号为i的基地到编号为a[i]的基地之间有一条道路，为了更加简洁的描述树状结构的基地群，有a[i]<i。

输出格式：
输出文件名为output.txt

输出文件仅有一个正整数，表示至少要设立多少个消防局才有能力及时扑灭任何基地发生的火灾。

输入输出样例
输入样例#1：
6
1
2
3
4
5
输出样例#1：
2
*/